{"version":3,"file":"lvShBcCt.js","sources":["../../../../../../unzipit/dist/unzipit.module.js"],"sourcesContent":["/* unzipit@1.4.3, license MIT */\n/* global SharedArrayBuffer, process */\n\nfunction readBlobAsArrayBuffer(blob) {\n  if (blob.arrayBuffer) {\n    return blob.arrayBuffer();\n  }\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.addEventListener('loadend', () => {\n      resolve(reader.result);\n    });\n    reader.addEventListener('error', reject);\n    reader.readAsArrayBuffer(blob);\n  });\n}\n\nasync function readBlobAsUint8Array(blob) {\n  const arrayBuffer = await readBlobAsArrayBuffer(blob);\n  return new Uint8Array(arrayBuffer);\n}\n\nfunction isBlob(v) {\n  return typeof Blob !== 'undefined' && v instanceof Blob;\n}\n\nfunction isSharedArrayBuffer(b) {\n  return typeof SharedArrayBuffer !== 'undefined' && b instanceof SharedArrayBuffer;\n}\n\nconst isNode =\n    (typeof process !== 'undefined') &&\n    process.versions &&\n    (typeof process.versions.node !== 'undefined') &&\n    (typeof process.versions.electron === 'undefined');\n\nfunction isTypedArraySameAsArrayBuffer(typedArray) {\n  return typedArray.byteOffset === 0 && typedArray.byteLength === typedArray.buffer.byteLength;\n}\n\nclass ArrayBufferReader {\n  constructor(arrayBufferOrView) {\n    this.typedArray = (arrayBufferOrView instanceof ArrayBuffer || isSharedArrayBuffer(arrayBufferOrView))\n       ? new Uint8Array(arrayBufferOrView)\n       : new Uint8Array(arrayBufferOrView.buffer, arrayBufferOrView.byteOffset, arrayBufferOrView.byteLength);\n  }\n  async getLength() {\n    return this.typedArray.byteLength;\n  }\n  async read(offset, length) {\n    return new Uint8Array(this.typedArray.buffer, this.typedArray.byteOffset + offset, length);\n  }\n}\n\nclass BlobReader {\n  constructor(blob) {\n    this.blob = blob;\n  }\n  async getLength() {\n    return this.blob.size;\n  }\n  async read(offset, length) {\n    const blob = this.blob.slice(offset, offset + length);\n    const arrayBuffer = await readBlobAsArrayBuffer(blob);\n    return new Uint8Array(arrayBuffer);\n  }\n  async sliceAsBlob(offset, length, type = '') {\n    return this.blob.slice(offset, offset + length, type);\n  }\n}\n\nclass HTTPRangeReader {\n  constructor(url) {\n    this.url = url;\n  }\n  async getLength() {\n    if (this.length === undefined) {\n      const req = await fetch(this.url, { method: 'HEAD' });\n      if (!req.ok) {\n        throw new Error(`failed http request ${this.url}, status: ${req.status}: ${req.statusText}`);\n      }\n      this.length = parseInt(req.headers.get('content-length'));\n      if (Number.isNaN(this.length)) {\n        throw Error('could not get length');\n      }\n    }\n    return this.length;\n  }\n  async read(offset, size) {\n    if (size === 0) {\n      return new Uint8Array(0);\n    }\n    const req = await fetch(this.url, {\n      headers: {\n        Range: `bytes=${offset}-${offset + size - 1}`,\n      },\n    });\n    if (!req.ok) {\n      throw new Error(`failed http request ${this.url}, status: ${req.status} offset: ${offset} size: ${size}: ${req.statusText}`);\n    }\n    const buffer = await req.arrayBuffer();\n    return new Uint8Array(buffer);\n  }\n}\n\nfunction inflate(data, buf) {\n\tvar u8=Uint8Array;\n\tif(data[0]==3 && data[1]==0) return (buf ? buf : new u8(0));\n\tvar bitsF = _bitsF, bitsE = _bitsE, decodeTiny = _decodeTiny, get17 = _get17;\n\t\n\tvar noBuf = (buf==null);\n\tif(noBuf) buf = new u8((data.length>>>2)<<3);\n\t\n\tvar BFINAL=0, BTYPE=0, HLIT=0, HDIST=0, HCLEN=0, ML=0, MD=0; \t\n\tvar off = 0, pos = 0;\n\tvar lmap, dmap;\n\t\n\twhile(BFINAL==0) {\t\t\n\t\tBFINAL = bitsF(data, pos  , 1);\n\t\tBTYPE  = bitsF(data, pos+1, 2);  pos+=3;\n\t\t//console.log(BFINAL, BTYPE);\n\t\t\n\t\tif(BTYPE==0) {\n\t\t\tif((pos&7)!=0) pos+=8-(pos&7);\n\t\t\tvar p8 = (pos>>>3)+4, len = data[p8-4]|(data[p8-3]<<8);  //console.log(len);//bitsF(data, pos, 16), \n\t\t\tif(noBuf) buf=_check(buf, off+len);\n\t\t\tbuf.set(new u8(data.buffer, data.byteOffset+p8, len), off);\n\t\t\t//for(var i=0; i<len; i++) buf[off+i] = data[p8+i];\n\t\t\t//for(var i=0; i<len; i++) if(buf[off+i] != data[p8+i]) throw \"e\";\n\t\t\tpos = ((p8+len)<<3);  off+=len;  continue;\n\t\t}\n\t\tif(noBuf) buf=_check(buf, off+(1<<17));  // really not enough in many cases (but PNG and ZIP provide buffer in advance)\n\t\tif(BTYPE==1) {  lmap = U.flmap;  dmap = U.fdmap;  ML = (1<<9)-1;  MD = (1<<5)-1;   }\n\t\tif(BTYPE==2) {\n\t\t\tHLIT  = bitsE(data, pos   , 5)+257;  \n\t\t\tHDIST = bitsE(data, pos+ 5, 5)+  1;  \n\t\t\tHCLEN = bitsE(data, pos+10, 4)+  4;  pos+=14;\n\t\t\tfor(var i=0; i<38; i+=2) {  U.itree[i]=0;  U.itree[i+1]=0;  }\n\t\t\tvar tl = 1;\n\t\t\tfor(var i=0; i<HCLEN; i++) {  var l=bitsE(data, pos+i*3, 3);  U.itree[(U.ordr[i]<<1)+1] = l;  if(l>tl)tl=l;  }     pos+=3*HCLEN;  //console.log(itree);\n\t\t\tmakeCodes(U.itree, tl);\n\t\t\tcodes2map(U.itree, tl, U.imap);\n\t\t\t\n\t\t\tlmap = U.lmap;  dmap = U.dmap;\n\t\t\t\n\t\t\tpos = decodeTiny(U.imap, (1<<tl)-1, HLIT+HDIST, data, pos, U.ttree);\n\t\t\tvar mx0 = _copyOut(U.ttree,    0, HLIT , U.ltree);  ML = (1<<mx0)-1;\n\t\t\tvar mx1 = _copyOut(U.ttree, HLIT, HDIST, U.dtree);  MD = (1<<mx1)-1;\n\t\t\t\n\t\t\t//var ml = decodeTiny(U.imap, (1<<tl)-1, HLIT , data, pos, U.ltree); ML = (1<<(ml>>>24))-1;  pos+=(ml&0xffffff);\n\t\t\tmakeCodes(U.ltree, mx0);\n\t\t\tcodes2map(U.ltree, mx0, lmap);\n\t\t\t\n\t\t\t//var md = decodeTiny(U.imap, (1<<tl)-1, HDIST, data, pos, U.dtree); MD = (1<<(md>>>24))-1;  pos+=(md&0xffffff);\n\t\t\tmakeCodes(U.dtree, mx1);\n\t\t\tcodes2map(U.dtree, mx1, dmap);\n\t\t}\n\t\t//var ooff=off, opos=pos;\n\t\twhile(true) {\n\t\t\tvar code = lmap[get17(data, pos) & ML];  pos += code&15;\n\t\t\tvar lit = code>>>4;  //U.lhst[lit]++;  \n\t\t\tif((lit>>>8)==0) {  buf[off++] = lit;  }\n\t\t\telse if(lit==256) {  break;  }\n\t\t\telse {\n\t\t\t\tvar end = off+lit-254;\n\t\t\t\tif(lit>264) { var ebs = U.ldef[lit-257];  end = off + (ebs>>>3) + bitsE(data, pos, ebs&7);  pos += ebs&7;  }\n\t\t\t\t//dst[end-off]++;\n\t\t\t\t\n\t\t\t\tvar dcode = dmap[get17(data, pos) & MD];  pos += dcode&15;\n\t\t\t\tvar dlit = dcode>>>4;\n\t\t\t\tvar dbs = U.ddef[dlit], dst = (dbs>>>4) + bitsF(data, pos, dbs&15);  pos += dbs&15;\n\t\t\t\t\n\t\t\t\t//var o0 = off-dst, stp = Math.min(end-off, dst);\n\t\t\t\t//if(stp>20) while(off<end) {  buf.copyWithin(off, o0, o0+stp);  off+=stp;  }  else\n\t\t\t\t//if(end-dst<=off) buf.copyWithin(off, off-dst, end-dst);  else\n\t\t\t\t//if(dst==1) buf.fill(buf[off-1], off, end);  else\n\t\t\t\tif(noBuf) buf=_check(buf, off+(1<<17));\n\t\t\t\twhile(off<end) {  buf[off]=buf[off++-dst];    buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  }   \n\t\t\t\toff=end;\n\t\t\t\t//while(off!=end) {  buf[off]=buf[off++-dst];  }\n\t\t\t}\n\t\t}\n\t\t//console.log(off-ooff, (pos-opos)>>>3);\n\t}\n\t//console.log(dst);\n\t//console.log(tlen, dlen, off-tlen+tcnt);\n\treturn buf.length==off ? buf : buf.slice(0,off);\n}\nfunction _check(buf, len) {\n\tvar bl=buf.length;  if(len<=bl) return buf;\n\tvar nbuf = new Uint8Array(Math.max(bl<<1,len));  nbuf.set(buf,0);\n\t//for(var i=0; i<bl; i+=4) {  nbuf[i]=buf[i];  nbuf[i+1]=buf[i+1];  nbuf[i+2]=buf[i+2];  nbuf[i+3]=buf[i+3];  }\n\treturn nbuf;\n}\n\nfunction _decodeTiny(lmap, LL, len, data, pos, tree) {\n\tvar bitsE = _bitsE, get17 = _get17;\n\tvar i = 0;\n\twhile(i<len) {\n\t\tvar code = lmap[get17(data, pos)&LL];  pos+=code&15;\n\t\tvar lit = code>>>4; \n\t\tif(lit<=15) {  tree[i]=lit;  i++;  }\n\t\telse {\n\t\t\tvar ll = 0, n = 0;\n\t\t\tif(lit==16) {\n\t\t\t\tn = (3  + bitsE(data, pos, 2));  pos += 2;  ll = tree[i-1];\n\t\t\t}\n\t\t\telse if(lit==17) {\n\t\t\t\tn = (3  + bitsE(data, pos, 3));  pos += 3;\n\t\t\t}\n\t\t\telse if(lit==18) {\n\t\t\t\tn = (11 + bitsE(data, pos, 7));  pos += 7;\n\t\t\t}\n\t\t\tvar ni = i+n;\n\t\t\twhile(i<ni) {  tree[i]=ll;  i++; }\n\t\t}\n\t}\n\treturn pos;\n}\nfunction _copyOut(src, off, len, tree) {\n\tvar mx=0, i=0, tl=tree.length>>>1;\n\twhile(i<len) {  var v=src[i+off];  tree[(i<<1)]=0;  tree[(i<<1)+1]=v;  if(v>mx)mx=v;  i++;  }\n\twhile(i<tl ) {  tree[(i<<1)]=0;  tree[(i<<1)+1]=0;  i++;  }\n\treturn mx;\n}\n\nfunction makeCodes(tree, MAX_BITS) {  // code, length\n\tvar max_code = tree.length;\n\tvar code, bits, n, i, len;\n\t\n\tvar bl_count = U.bl_count;  for(var i=0; i<=MAX_BITS; i++) bl_count[i]=0;\n\tfor(i=1; i<max_code; i+=2) bl_count[tree[i]]++;\n\t\n\tvar next_code = U.next_code;\t// smallest code for each length\n\t\n\tcode = 0;\n\tbl_count[0] = 0;\n\tfor (bits = 1; bits <= MAX_BITS; bits++) {\n\t\tcode = (code + bl_count[bits-1]) << 1;\n\t\tnext_code[bits] = code;\n\t}\n\t\n\tfor (n = 0; n < max_code; n+=2) {\n\t\tlen = tree[n+1];\n\t\tif (len != 0) {\n\t\t\ttree[n] = next_code[len];\n\t\t\tnext_code[len]++;\n\t\t}\n\t}\n}\nfunction codes2map(tree, MAX_BITS, map) {\n\tvar max_code = tree.length;\n\tvar r15 = U.rev15;\n\tfor(var i=0; i<max_code; i+=2) if(tree[i+1]!=0)  {\n\t\tvar lit = i>>1;\n\t\tvar cl = tree[i+1], val = (lit<<4)|cl; // :  (0x8000 | (U.of0[lit-257]<<7) | (U.exb[lit-257]<<4) | cl);\n\t\tvar rest = (MAX_BITS-cl), i0 = tree[i]<<rest, i1 = i0 + (1<<rest);\n\t\t//tree[i]=r15[i0]>>>(15-MAX_BITS);\n\t\twhile(i0!=i1) {\n\t\t\tvar p0 = r15[i0]>>>(15-MAX_BITS);\n\t\t\tmap[p0]=val;  i0++;\n\t\t}\n\t}\n}\nfunction revCodes(tree, MAX_BITS) {\n\tvar r15 = U.rev15, imb = 15-MAX_BITS;\n\tfor(var i=0; i<tree.length; i+=2) {  var i0 = (tree[i]<<(MAX_BITS-tree[i+1]));  tree[i] = r15[i0]>>>imb;  }\n}\n\nfunction _bitsE(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8)                        )>>>(pos&7))&((1<<length)-1);  }\nfunction _bitsF(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16))>>>(pos&7))&((1<<length)-1);  }\n/*\nfunction _get9(dt, pos) {\n\treturn ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8))>>>(pos&7))&511;\n} */\nfunction _get17(dt, pos) {\t// return at least 17 meaningful bytes\n\treturn (dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16) )>>>(pos&7);\n}\nconst U = function(){\n\tvar u16=Uint16Array, u32=Uint32Array;\n\treturn {\n\t\tnext_code : new u16(16),\n\t\tbl_count  : new u16(16),\n\t\tordr : [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ],\n\t\tof0  : [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],\n\t\texb  : [0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0,  0,  0,  0],\n\t\tldef : new u16(32),\n\t\tdf0  : [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 65535, 65535],\n\t\tdxb  : [0,0,0,0,1,1,2, 2, 3, 3, 4, 4, 5, 5,  6,  6,  7,  7,  8,  8,   9,   9,  10,  10,  11,  11,  12,   12,   13,   13,     0,     0],\n\t\tddef : new u32(32),\n\t\tflmap: new u16(  512),  fltree: [],\n\t\tfdmap: new u16(   32),  fdtree: [],\n\t\tlmap : new u16(32768),  ltree : [],  ttree:[],\n\t\tdmap : new u16(32768),  dtree : [],\n\t\timap : new u16(  512),  itree : [],\n\t\t//rev9 : new u16(  512)\n\t\trev15: new u16(1<<15),\n\t\tlhst : new u32(286), dhst : new u32( 30), ihst : new u32(19),\n\t\tlits : new u32(15000),\n\t\tstrt : new u16(1<<16),\n\t\tprev : new u16(1<<15)\n\t};  \n} ();\n\n(function(){\t\n\tvar len = 1<<15;\n\tfor(var i=0; i<len; i++) {\n\t\tvar x = i;\n\t\tx = (((x & 0xaaaaaaaa) >>> 1) | ((x & 0x55555555) << 1));\n\t\tx = (((x & 0xcccccccc) >>> 2) | ((x & 0x33333333) << 2));\n\t\tx = (((x & 0xf0f0f0f0) >>> 4) | ((x & 0x0f0f0f0f) << 4));\n\t\tx = (((x & 0xff00ff00) >>> 8) | ((x & 0x00ff00ff) << 8));\n\t\tU.rev15[i] = (((x >>> 16) | (x << 16)))>>>17;\n\t}\n\t\n\tfunction pushV(tgt, n, sv) {  while(n--!=0) tgt.push(0,sv);  }\n\t\n\tfor(var i=0; i<32; i++) {  U.ldef[i]=(U.of0[i]<<3)|U.exb[i];  U.ddef[i]=(U.df0[i]<<4)|U.dxb[i];  }\n\t\n\tpushV(U.fltree, 144, 8);  pushV(U.fltree, 255-143, 9);  pushV(U.fltree, 279-255, 7);  pushV(U.fltree,287-279,8);\n\t/*\n\tvar i = 0;\n\tfor(; i<=143; i++) U.fltree.push(0,8);\n\tfor(; i<=255; i++) U.fltree.push(0,9);\n\tfor(; i<=279; i++) U.fltree.push(0,7);\n\tfor(; i<=287; i++) U.fltree.push(0,8);\n\t*/\n\tmakeCodes(U.fltree, 9);\n\tcodes2map(U.fltree, 9, U.flmap);\n\trevCodes (U.fltree, 9);\n\t\n\tpushV(U.fdtree,32,5);\n\t//for(i=0;i<32; i++) U.fdtree.push(0,5);\n\tmakeCodes(U.fdtree, 5);\n\tcodes2map(U.fdtree, 5, U.fdmap);\n\trevCodes (U.fdtree, 5);\n\t\n\tpushV(U.itree,19,0);  pushV(U.ltree,286,0);  pushV(U.dtree,30,0);  pushV(U.ttree,320,0);\n\t/*\n\tfor(var i=0; i< 19; i++) U.itree.push(0,0);\n\tfor(var i=0; i<286; i++) U.ltree.push(0,0);\n\tfor(var i=0; i< 30; i++) U.dtree.push(0,0);\n\tfor(var i=0; i<320; i++) U.ttree.push(0,0);\n\t*/\n})();\n\nconst crc = {\r\n\ttable : ( function() {\r\n\t   var tab = new Uint32Array(256);\r\n\t   for (var n=0; n<256; n++) {\r\n\t\t\tvar c = n;\r\n\t\t\tfor (var k=0; k<8; k++) {\r\n\t\t\t\tif (c & 1)  c = 0xedb88320 ^ (c >>> 1);\r\n\t\t\t\telse        c = c >>> 1;\r\n\t\t\t}\r\n\t\t\ttab[n] = c;  }    \r\n\t\treturn tab;  })(),\r\n\tupdate : function(c, buf, off, len) {\r\n\t\tfor (var i=0; i<len; i++)  c = crc.table[(c ^ buf[off+i]) & 0xff] ^ (c >>> 8);\r\n\t\treturn c;\r\n\t},\r\n\tcrc : function(b,o,l)  {  return crc.update(0xffffffff,b,o,l) ^ 0xffffffff;  }\r\n};\r\n\r\nfunction inflateRaw(file, buf) {  return inflate(file, buf);  }\n\n/* global module */\n\nconst config = {\n  numWorkers: 1,\n  workerURL: '',\n  useWorkers: false,\n};\n\nlet nextId = 0;\n\n// Requests are put on a queue.\n// We don't send the request to the worker until the worker\n// is finished. This probably adds a small amount of latency\n// but the issue is imagine you have 2 workers. You give worker\n// A x seconds of work to do and worker B y seconds of work to\n// do. You don't know which will finish first. If you give\n// the worker with more work to do the request then you'll\n// waste time.\n\n// note: we can't check `workers.length` for deciding if\n// we've reached `config.numWorkers` because creation the worker\n// is async which means other requests to make workers might\n// come in before a worker gets added to `workers`\nlet numWorkers = 0;\nlet canUseWorkers = true;   // gets set to false if we can't start a worker\nconst workers = [];\nconst availableWorkers = [];\nconst waitingForWorkerQueue = [];\nconst currentlyProcessingIdToRequestMap = new Map();\n\nfunction handleResult(e) {\n  makeWorkerAvailable(e.target);\n  const {id, error, data} = e.data;\n  const request = currentlyProcessingIdToRequestMap.get(id);\n  currentlyProcessingIdToRequestMap.delete(id);\n  if (error) {\n    request.reject(error);\n  } else {\n    request.resolve(data);\n  }\n}\n\n// Because Firefox uses non-standard onerror to signal an error.\nfunction startWorker(url) {\n  return new Promise((resolve, reject) => {\n    const worker = new Worker(url);\n    worker.onmessage = (e) => {\n      if (e.data === 'start') {\n        worker.onerror = undefined;\n        worker.onmessage = undefined;\n        resolve(worker);\n      } else {\n        reject(new Error(`unexpected message: ${e.data}`));\n      }\n    };\n    worker.onerror = reject;\n  });\n}\n\nfunction dynamicRequire(mod, request) {\n  return mod.require ? mod.require(request) : {};\n}\n\nconst workerHelper = (function() {\n  if (isNode) {\n    // We need to use `dynamicRequire` because `require` on it's own will be optimized by webpack.\n    const {Worker} = dynamicRequire(module, 'worker_threads');\n    return {\n      async createWorker(url) {\n        return new Worker(url);\n      },\n      addEventListener(worker, fn) {\n        worker.on('message', (data) => {\n          fn({target: worker, data});\n        });\n      },\n      async terminate(worker) {\n        await worker.terminate();\n      },\n    };\n  } else {\n    return {\n      async createWorker(url) {\n        // I don't understand this security issue\n        // Apparently there is some iframe setting or http header\n        // that prevents cross domain workers. But, I can manually\n        // download the text and do it. I reported this to Chrome\n        // and they said it was fine so ¯\\_(ツ)_/¯\n        try {\n          const worker = await startWorker(url);\n          return worker;\n        } catch (e) {\n          console.warn('could not load worker:', url);\n        }\n\n        let text;\n        try {\n          const req = await fetch(url, {mode: 'cors'});\n          if (!req.ok) {\n            throw new Error(`could not load: ${url}`);\n          }\n          text = await req.text();\n          url = URL.createObjectURL(new Blob([text], {type: 'application/javascript'}));\n          const worker = await startWorker(url);\n          config.workerURL = url;  // this is a hack. What's a better way to structure this code?\n          return worker;\n        } catch (e) {\n          console.warn('could not load worker via fetch:', url);\n        }\n\n        if (text !== undefined) {\n          try {\n            url = `data:application/javascript;base64,${btoa(text)}`;\n            const worker = await startWorker(url);\n            config.workerURL = url;\n            return worker;\n          } catch (e) {\n            console.warn('could not load worker via dataURI');\n          }\n        }\n\n        console.warn('workers will not be used');\n        throw new Error('can not start workers');\n      },\n      addEventListener(worker, fn) {\n        worker.addEventListener('message', fn);\n      },\n      async terminate(worker) {\n        worker.terminate();\n      },\n    };\n  }\n}());\n\nfunction makeWorkerAvailable(worker) {\n  availableWorkers.push(worker);\n  processWaitingForWorkerQueue();\n}\n\nasync function getAvailableWorker() {\n  if (availableWorkers.length === 0 && numWorkers < config.numWorkers) {\n    ++numWorkers;  // see comment at numWorkers declaration\n    try {\n      const worker = await workerHelper.createWorker(config.workerURL);\n      workers.push(worker);\n      availableWorkers.push(worker);\n      workerHelper.addEventListener(worker, handleResult);\n    } catch (e) {\n      // set this global out-of-band (needs refactor)\n      canUseWorkers = false;\n    }\n  }\n  return availableWorkers.pop();\n}\n\n// @param {Uint8Array} src\n// @param {number} uncompressedSize\n// @param {string} [type] mime-type\n// @returns {ArrayBuffer|Blob} ArrayBuffer if type is falsy or Blob otherwise.\nfunction inflateRawLocal(src, uncompressedSize, type, resolve) {\n  const dst = new Uint8Array(uncompressedSize);\n  inflateRaw(src, dst);\n  resolve(type\n     ? new Blob([dst], {type})\n     : dst.buffer);\n}\n\nasync function processWaitingForWorkerQueue() {\n  if (waitingForWorkerQueue.length === 0) {\n    return;\n  }\n\n  if (config.useWorkers && canUseWorkers) {\n    const worker = await getAvailableWorker();\n    // canUseWorkers might have been set out-of-band (need refactor)\n    if (canUseWorkers) {\n      if (worker) {\n        if (waitingForWorkerQueue.length === 0) {\n          // the queue might be empty while we awaited for a worker.\n          makeWorkerAvailable(worker);\n          return;\n        }\n        const {id, src, uncompressedSize, type, resolve, reject} = waitingForWorkerQueue.shift();\n        currentlyProcessingIdToRequestMap.set(id, {id, resolve, reject});\n        const transferables = [];\n        // NOTE: Originally I thought you could transfer an ArrayBuffer.\n        // The code on this side is often using views into the entire file\n        // which means if we transferred we'd lose the entire file. That sucks\n        // because it means there's an expensive copy to send the uncompressed\n        // data to the worker.\n        //\n        // Also originally I thought we could send a Blob but we'd need to refactor\n        // the code in unzipit/readEntryData as currently it reads the uncompressed\n        // bytes.\n        //\n        //if (!isBlob(src) && !isSharedArrayBuffer(src)) {\n        //  transferables.push(src);\n        //}\n        worker.postMessage({\n          type: 'inflate',\n          data: {\n            id,\n            type,\n            src,\n            uncompressedSize,\n          },\n        }, transferables);\n      }\n      return;\n    }\n  }\n\n  // inflate locally\n  // We loop here because what happens if many requests happen at once\n  // the first N requests will try to async make a worker. Other requests\n  // will then be on the queue. But if we fail to make workers then there\n  // are pending requests.\n  while (waitingForWorkerQueue.length) {\n    const {src, uncompressedSize, type, resolve} = waitingForWorkerQueue.shift();\n    let data = src;\n    if (isBlob(src)) {\n      data = await readBlobAsUint8Array(src);\n    }\n    inflateRawLocal(data, uncompressedSize, type, resolve);\n  }\n}\n\nfunction setOptions(options) {\n  config.workerURL = options.workerURL || config.workerURL;\n  // there's no reason to set the workerURL if you're not going to use workers\n  if (options.workerURL) {\n    config.useWorkers = true;\n  }\n  config.useWorkers = options.useWorkers !== undefined ? options.useWorkers : config.useWorkers;\n  config.numWorkers = options.numWorkers || config.numWorkers;\n}\n\n// It has to take non-zero time to put a large typed array in a Blob since the very\n// next instruction you could change the contents of the array. So, if you're reading\n// the zip file for images/video/audio then all you want is a Blob on which to get a URL.\n// so that operation of putting the data in a Blob should happen in the worker.\n//\n// Conversely if you want the data itself then you want an ArrayBuffer immediately\n// since the worker can transfer its ArrayBuffer zero copy.\n//\n// @param {Uint8Array|Blob} src\n// @param {number} uncompressedSize\n// @param {string} [type] falsy or mimeType string (eg: 'image/png')\n// @returns {ArrayBuffer|Blob} ArrayBuffer if type is falsy or Blob otherwise.\nfunction inflateRawAsync(src, uncompressedSize, type) {\n  return new Promise((resolve, reject) => {\n    // note: there is potential an expensive copy here. In order for the data\n    // to make it into the worker we need to copy the data to the worker unless\n    // it's a Blob or a SharedArrayBuffer.\n    //\n    // Solutions:\n    //\n    // 1. A minor enhancement, if `uncompressedSize` is small don't call the worker.\n    //\n    //    might be a win period as their is overhead calling the worker\n    //\n    // 2. Move the entire library to the worker\n    //\n    //    Good, Maybe faster if you pass a URL, Blob, or SharedArrayBuffer? Not sure about that\n    //    as those are also easy to transfer. Still slow if you pass an ArrayBuffer\n    //    as the ArrayBuffer has to be copied to the worker.\n    //\n    // I guess benchmarking is really the only thing to try.\n    waitingForWorkerQueue.push({src, uncompressedSize, type, resolve, reject, id: nextId++});\n    processWaitingForWorkerQueue();\n  });\n}\n\nfunction clearArray(arr) {\n  arr.splice(0, arr.length);\n}\n\nasync function cleanup() {\n  for (const worker of workers) {\n    await workerHelper.terminate(worker);\n  }\n  clearArray(workers);\n  clearArray(availableWorkers);\n  clearArray(waitingForWorkerQueue);\n  currentlyProcessingIdToRequestMap.clear();\n  numWorkers = 0;\n  canUseWorkers = true;\n}\n\n/*\nclass Zip {\n  constructor(reader) {\n    comment,  // the comment for this entry\n    commentBytes, // the raw comment for this entry\n  }\n}\n*/\n\nfunction dosDateTimeToDate(date, time) {\n  const day = date & 0x1f; // 1-31\n  const month = (date >> 5 & 0xf) - 1; // 1-12, 0-11\n  const year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108\n\n  const millisecond = 0;\n  const second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)\n  const minute = time >> 5 & 0x3f; // 0-59\n  const hour = time >> 11 & 0x1f; // 0-23\n\n  return new Date(year, month, day, hour, minute, second, millisecond);\n}\n\nclass ZipEntry {\n  constructor(reader, rawEntry) {\n    this._reader = reader;\n    this._rawEntry = rawEntry;\n    this.name = rawEntry.name;\n    this.nameBytes = rawEntry.nameBytes;\n    this.size = rawEntry.uncompressedSize;\n    this.compressedSize = rawEntry.compressedSize;\n    this.comment = rawEntry.comment;\n    this.commentBytes = rawEntry.commentBytes;\n    this.compressionMethod = rawEntry.compressionMethod;\n    this.lastModDate = dosDateTimeToDate(rawEntry.lastModFileDate, rawEntry.lastModFileTime);\n    this.isDirectory = rawEntry.uncompressedSize === 0 && rawEntry.name.endsWith('/');\n    this.encrypted = !!(rawEntry.generalPurposeBitFlag & 0x1);\n    this.externalFileAttributes = rawEntry.externalFileAttributes;\n    this.versionMadeBy = rawEntry.versionMadeBy;\n  }\n  // returns a promise that returns a Blob for this entry\n  async blob(type = 'application/octet-stream') {\n    return await readEntryDataAsBlob(this._reader, this._rawEntry, type);\n  }\n  // returns a promise that returns an ArrayBuffer for this entry\n  async arrayBuffer() {\n    return await readEntryDataAsArrayBuffer(this._reader, this._rawEntry);\n  }\n  // returns text, assumes the text is valid utf8. If you want more options decode arrayBuffer yourself\n  async text() {\n    const buffer = await this.arrayBuffer();\n    return decodeBuffer(new Uint8Array(buffer));\n  }\n  // returns text with JSON.parse called on it. If you want more options decode arrayBuffer yourself\n  async json() {\n    const text = await this.text();\n    return JSON.parse(text);\n  }\n}\n\nconst EOCDR_WITHOUT_COMMENT_SIZE = 22;\nconst MAX_COMMENT_SIZE = 0xffff; // 2-byte size\nconst EOCDR_SIGNATURE = 0x06054b50;\nconst ZIP64_EOCDR_SIGNATURE = 0x06064b50;\n\nasync function readAs(reader, offset, length) {\n  return await reader.read(offset, length);\n}\n\n// The point of this function is we want to be able to pass the data\n// to a worker as fast as possible so when decompressing if the data\n// is already a blob and we can get a blob then get a blob.\n//\n// I'm not sure what a better way to refactor this is. We've got examples\n// of multiple readers. Ideally, for every type of reader we could ask\n// it, \"give me a type that is zero copy both locally and when sent to a worker\".\n//\n// The problem is the worker would also have to know the how to handle this\n// opaque type. I suppose the correct solution is to register different\n// reader handlers in the worker so BlobReader would register some\n// `handleZeroCopyType<BlobReader>`. At the moment I don't feel like\n// refactoring. As it is you just pass in an instance of the reader\n// but instead you'd have to register the reader and some how get the\n// source for the `handleZeroCopyType` handler function into the worker.\n// That sounds like a huge PITA, requiring you to put the implementation\n// in a separate file so the worker can load it or some other workaround\n// hack.\n//\n// For now this hack works even if it's not generic.\nasync function readAsBlobOrTypedArray(reader, offset, length, type) {\n  if (reader.sliceAsBlob) {\n    return await reader.sliceAsBlob(offset, length, type);\n  }\n  return await reader.read(offset, length);\n}\n\nconst crc$1 = {\n  unsigned() {\n    return 0;\n  },\n};\n\nfunction getUint16LE(uint8View, offset) {\n  return uint8View[offset    ] +\n         uint8View[offset + 1] * 0x100;\n}\n\nfunction getUint32LE(uint8View, offset) {\n  return uint8View[offset    ] +\n         uint8View[offset + 1] * 0x100 +\n         uint8View[offset + 2] * 0x10000 +\n         uint8View[offset + 3] * 0x1000000;\n}\n\nfunction getUint64LE(uint8View, offset) {\n  return getUint32LE(uint8View, offset) +\n         getUint32LE(uint8View, offset + 4) * 0x100000000;\n}\n\n/* eslint-disable no-irregular-whitespace */\n// const decodeCP437 = (function() {\n//   const cp437 = '\\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';\n//\n//   return function(uint8view) {\n//     return Array.from(uint8view).map(v => cp437[v]).join('');\n//   };\n// }());\n/* eslint-enable no-irregular-whitespace */\n\nconst utf8Decoder = new TextDecoder();\nfunction decodeBuffer(uint8View, isUTF8) {  /* eslint-disable-line no-unused-vars */ /* lgtm [js/superfluous-trailing-arguments] */\n  if (isSharedArrayBuffer(uint8View.buffer)) {\n    uint8View = new Uint8Array(uint8View);\n  }\n  return utf8Decoder.decode(uint8View);\n  /*\n  AFAICT the UTF8 flat is not set so it's 100% up to the user\n  to self decode if their file is not utf8 filenames\n  return isUTF8\n      ? utf8Decoder.decode(uint8View)\n      : decodeCP437(uint8View);\n  */\n}\n\nasync function findEndOfCentralDirector(reader, totalLength) {\n  const size = Math.min(EOCDR_WITHOUT_COMMENT_SIZE + MAX_COMMENT_SIZE, totalLength);\n  const readStart = totalLength - size;\n  const data = await readAs(reader, readStart, size);\n  for (let i = size - EOCDR_WITHOUT_COMMENT_SIZE; i >= 0; --i) {\n    if (getUint32LE(data, i) !== EOCDR_SIGNATURE) {\n      continue;\n    }\n\n    // 0 - End of central directory signature\n    const eocdr = new Uint8Array(data.buffer, data.byteOffset + i, data.byteLength - i);\n    // 4 - Number of this disk\n    const diskNumber = getUint16LE(eocdr, 4);\n    if (diskNumber !== 0) {\n      throw new Error(`multi-volume zip files are not supported. This is volume: ${diskNumber}`);\n    }\n\n    // 6 - Disk where central directory starts\n    // 8 - Number of central directory records on this disk\n    // 10 - Total number of central directory records\n    const entryCount = getUint16LE(eocdr, 10);\n    // 12 - Size of central directory (bytes)\n    const centralDirectorySize = getUint32LE(eocdr, 12);\n    // 16 - Offset of start of central directory, relative to start of archive\n    const centralDirectoryOffset = getUint32LE(eocdr, 16);\n    // 20 - Comment length\n    const commentLength = getUint16LE(eocdr, 20);\n    const expectedCommentLength = eocdr.length - EOCDR_WITHOUT_COMMENT_SIZE;\n    if (commentLength !== expectedCommentLength) {\n      throw new Error(`invalid comment length. expected: ${expectedCommentLength}, actual: ${commentLength}`);\n    }\n\n    // 22 - Comment\n    // the encoding is always cp437.\n    const commentBytes = new Uint8Array(eocdr.buffer, eocdr.byteOffset + 22, commentLength);\n    const comment = decodeBuffer(commentBytes);\n\n    if (entryCount === 0xffff || centralDirectoryOffset === 0xffffffff) {\n      return await readZip64CentralDirectory(reader, readStart + i, comment, commentBytes);\n    } else {\n      return await readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);\n    }\n  }\n\n  throw new Error('could not find end of central directory. maybe not zip file');\n}\n\nconst END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE = 0x07064b50;\n\nasync function readZip64CentralDirectory(reader, offset, comment, commentBytes) {\n  // ZIP64 Zip64 end of central directory locator\n  const zip64EocdlOffset = offset - 20;\n  const eocdl = await readAs(reader, zip64EocdlOffset, 20);\n\n  // 0 - zip64 end of central dir locator signature\n  if (getUint32LE(eocdl, 0) !== END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE) {\n    throw new Error('invalid zip64 end of central directory locator signature');\n  }\n\n  // 4 - number of the disk with the start of the zip64 end of central directory\n  // 8 - relative offset of the zip64 end of central directory record\n  const zip64EocdrOffset = getUint64LE(eocdl, 8);\n  // 16 - total number of disks\n\n  // ZIP64 end of central directory record\n  const zip64Eocdr = await readAs(reader, zip64EocdrOffset, 56);\n\n  // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)\n  if (getUint32LE(zip64Eocdr, 0) !== ZIP64_EOCDR_SIGNATURE) {\n    throw new Error('invalid zip64 end of central directory record signature');\n  }\n  // 4 - size of zip64 end of central directory record                8 bytes\n  // 12 - version made by                                             2 bytes\n  // 14 - version needed to extract                                   2 bytes\n  // 16 - number of this disk                                         4 bytes\n  // 20 - number of the disk with the start of the central directory  4 bytes\n  // 24 - total number of entries in the central directory on this disk         8 bytes\n  // 32 - total number of entries in the central directory            8 bytes\n  const entryCount = getUint64LE(zip64Eocdr, 32);\n  // 40 - size of the central directory                               8 bytes\n  const centralDirectorySize = getUint64LE(zip64Eocdr, 40);\n  // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n  const centralDirectoryOffset = getUint64LE(zip64Eocdr, 48);\n  // 56 - zip64 extensible data sector                                (variable size)\n  return readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);\n}\n\nconst CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE = 0x02014b50;\n\nasync function readEntries(reader, centralDirectoryOffset, centralDirectorySize, rawEntryCount, comment, commentBytes) {\n  let readEntryCursor = 0;\n  const allEntriesBuffer = await readAs(reader, centralDirectoryOffset, centralDirectorySize);\n  const rawEntries = [];\n\n  for (let e = 0; e < rawEntryCount; ++e) {\n    const buffer = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + 46);\n    // 0 - Central directory file header signature\n    const signature = getUint32LE(buffer, 0);\n    if (signature !== CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE) {\n      throw new Error(`invalid central directory file header signature: 0x${signature.toString(16)}`);\n    }\n    const rawEntry = {\n      // 4 - Version made by\n      versionMadeBy: getUint16LE(buffer, 4),\n      // 6 - Version needed to extract (minimum)\n      versionNeededToExtract: getUint16LE(buffer, 6),\n      // 8 - General purpose bit flag\n      generalPurposeBitFlag: getUint16LE(buffer, 8),\n      // 10 - Compression method\n      compressionMethod: getUint16LE(buffer, 10),\n      // 12 - File last modification time\n      lastModFileTime: getUint16LE(buffer, 12),\n      // 14 - File last modification date\n      lastModFileDate: getUint16LE(buffer, 14),\n      // 16 - CRC-32\n      crc32: getUint32LE(buffer, 16),\n      // 20 - Compressed size\n      compressedSize: getUint32LE(buffer, 20),\n      // 24 - Uncompressed size\n      uncompressedSize: getUint32LE(buffer, 24),\n      // 28 - File name length (n)\n      fileNameLength: getUint16LE(buffer, 28),\n      // 30 - Extra field length (m)\n      extraFieldLength: getUint16LE(buffer, 30),\n      // 32 - File comment length (k)\n      fileCommentLength: getUint16LE(buffer, 32),\n      // 34 - Disk number where file starts\n      // 36 - Internal file attributes\n      internalFileAttributes: getUint16LE(buffer, 36),\n      // 38 - External file attributes\n      externalFileAttributes: getUint32LE(buffer, 38),\n      // 42 - Relative offset of local file header\n      relativeOffsetOfLocalHeader: getUint32LE(buffer, 42),\n    };\n\n    if (rawEntry.generalPurposeBitFlag & 0x40) {\n      throw new Error('strong encryption is not supported');\n    }\n\n    readEntryCursor += 46;\n\n    const data = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + rawEntry.fileNameLength + rawEntry.extraFieldLength + rawEntry.fileCommentLength);\n    rawEntry.nameBytes = data.slice(0, rawEntry.fileNameLength);\n    rawEntry.name = decodeBuffer(rawEntry.nameBytes);\n\n    // 46+n - Extra field\n    const fileCommentStart = rawEntry.fileNameLength + rawEntry.extraFieldLength;\n    const extraFieldBuffer = data.slice(rawEntry.fileNameLength, fileCommentStart);\n    rawEntry.extraFields = [];\n    let i = 0;\n    while (i < extraFieldBuffer.length - 3) {\n      const headerId = getUint16LE(extraFieldBuffer, i + 0);\n      const dataSize = getUint16LE(extraFieldBuffer, i + 2);\n      const dataStart = i + 4;\n      const dataEnd = dataStart + dataSize;\n      if (dataEnd > extraFieldBuffer.length) {\n        throw new Error('extra field length exceeds extra field buffer size');\n      }\n      rawEntry.extraFields.push({\n        id: headerId,\n        data: extraFieldBuffer.slice(dataStart, dataEnd),\n      });\n      i = dataEnd;\n    }\n\n    // 46+n+m - File comment\n    rawEntry.commentBytes = data.slice(fileCommentStart, fileCommentStart + rawEntry.fileCommentLength);\n    rawEntry.comment = decodeBuffer(rawEntry.commentBytes);\n\n    readEntryCursor += data.length;\n\n    if (rawEntry.uncompressedSize            === 0xffffffff ||\n        rawEntry.compressedSize              === 0xffffffff ||\n        rawEntry.relativeOffsetOfLocalHeader === 0xffffffff) {\n      // ZIP64 format\n      // find the Zip64 Extended Information Extra Field\n      const zip64ExtraField = rawEntry.extraFields.find(e => e.id === 0x0001);\n      if (!zip64ExtraField) {\n        throw new Error('expected zip64 extended information extra field');\n      }\n      const zip64EiefBuffer = zip64ExtraField.data;\n      let index = 0;\n      // 0 - Original Size          8 bytes\n      if (rawEntry.uncompressedSize === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include uncompressed size');\n        }\n        rawEntry.uncompressedSize = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      }\n      // 8 - Compressed Size        8 bytes\n      if (rawEntry.compressedSize === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include compressed size');\n        }\n        rawEntry.compressedSize = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      }\n      // 16 - Relative Header Offset 8 bytes\n      if (rawEntry.relativeOffsetOfLocalHeader === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include relative header offset');\n        }\n        rawEntry.relativeOffsetOfLocalHeader = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      }\n      // 24 - Disk Start Number      4 bytes\n    }\n\n    // check for Info-ZIP Unicode Path Extra Field (0x7075)\n    // see https://github.com/thejoshwolfe/yauzl/issues/33\n    const nameField = rawEntry.extraFields.find(e =>\n        e.id === 0x7075 &&\n        e.data.length >= 6 && // too short to be meaningful\n        e.data[0] === 1 &&    // Version       1 byte      version of this extra field, currently 1\n        getUint32LE(e.data, 1), crc$1.unsigned(rawEntry.nameBytes)); // NameCRC32     4 bytes     File Name Field CRC32 Checksum\n                                                                   // > If the CRC check fails, this UTF-8 Path Extra Field should be\n                                                                   // > ignored and the File Name field in the header should be used instead.\n    if (nameField) {\n        // UnicodeName Variable UTF-8 version of the entry File Name\n        rawEntry.fileName = decodeBuffer(nameField.data.slice(5));\n    }\n\n    // validate file size\n    if (rawEntry.compressionMethod === 0) {\n      let expectedCompressedSize = rawEntry.uncompressedSize;\n      if ((rawEntry.generalPurposeBitFlag & 0x1) !== 0) {\n        // traditional encryption prefixes the file data with a header\n        expectedCompressedSize += 12;\n      }\n      if (rawEntry.compressedSize !== expectedCompressedSize) {\n        throw new Error(`compressed size mismatch for stored file: ${rawEntry.compressedSize} != ${expectedCompressedSize}`);\n      }\n    }\n    rawEntries.push(rawEntry);\n  }\n  const zip = {\n    comment,\n    commentBytes,\n  };\n  return {\n    zip,\n    entries: rawEntries.map(e => new ZipEntry(reader, e)),\n  };\n}\n\nasync function readEntryDataHeader(reader, rawEntry) {\n  if (rawEntry.generalPurposeBitFlag & 0x1) {\n    throw new Error('encrypted entries not supported');\n  }\n  const buffer = await readAs(reader, rawEntry.relativeOffsetOfLocalHeader, 30);\n  // note: maybe this should be passed in or cached on entry\n  // as it's async so there will be at least one tick (not sure about that)\n  const totalLength = await reader.getLength();\n\n  // 0 - Local file header signature = 0x04034b50\n  const signature = getUint32LE(buffer, 0);\n  if (signature !== 0x04034b50) {\n    throw new Error(`invalid local file header signature: 0x${signature.toString(16)}`);\n  }\n\n  // all this should be redundant\n  // 4 - Version needed to extract (minimum)\n  // 6 - General purpose bit flag\n  // 8 - Compression method\n  // 10 - File last modification time\n  // 12 - File last modification date\n  // 14 - CRC-32\n  // 18 - Compressed size\n  // 22 - Uncompressed size\n  // 26 - File name length (n)\n  const fileNameLength = getUint16LE(buffer, 26);\n  // 28 - Extra field length (m)\n  const extraFieldLength = getUint16LE(buffer, 28);\n  // 30 - File name\n  // 30+n - Extra field\n  const localFileHeaderEnd = rawEntry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;\n  let decompress;\n  if (rawEntry.compressionMethod === 0) {\n    // 0 - The file is stored (no compression)\n    decompress = false;\n  } else if (rawEntry.compressionMethod === 8) {\n    // 8 - The file is Deflated\n    decompress = true;\n  } else {\n    throw new Error(`unsupported compression method: ${rawEntry.compressionMethod}`);\n  }\n  const fileDataStart = localFileHeaderEnd;\n  const fileDataEnd = fileDataStart + rawEntry.compressedSize;\n  if (rawEntry.compressedSize !== 0) {\n    // bounds check now, because the read streams will probably not complain loud enough.\n    // since we're dealing with an unsigned offset plus an unsigned size,\n    // we only have 1 thing to check for.\n    if (fileDataEnd > totalLength) {\n      throw new Error(`file data overflows file bounds: ${fileDataStart} +  ${rawEntry.compressedSize}  > ${totalLength}`);\n    }\n  }\n  return {\n    decompress,\n    fileDataStart,\n  };\n}\n\nasync function readEntryDataAsArrayBuffer(reader, rawEntry) {\n  const {decompress, fileDataStart} = await readEntryDataHeader(reader, rawEntry);\n  if (!decompress) {\n    const dataView = await readAs(reader, fileDataStart, rawEntry.compressedSize);\n    // make copy?\n    //\n    // 1. The source is a Blob/file. In this case we'll get back TypedArray we can just hand to the user\n    // 2. The source is a TypedArray. In this case we'll get back TypedArray that is a view into a larger buffer\n    //    but because ultimately this is used to return an ArrayBuffer to `someEntry.arrayBuffer()`\n    //    we need to return copy since we need the `ArrayBuffer`, not the TypedArray to exactly match the data.\n    //    Note: We could add another API function `bytes()` or something that returned a `Uint8Array`\n    //    instead of an `ArrayBuffer`. This would let us skip a copy here. But this case only happens for uncompressed\n    //    data. That seems like a rare enough case that adding a new API is not worth it? Or is it? A zip of jpegs or mp3s\n    //    might not be compressed. For now that's a TBD.\n    return isTypedArraySameAsArrayBuffer(dataView) ? dataView.buffer : dataView.slice().buffer;\n  }\n  // see comment in readEntryDateAsBlob\n  const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize);\n  const result = await inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize);\n  return result;\n}\n\nasync function readEntryDataAsBlob(reader, rawEntry, type) {\n  const {decompress, fileDataStart} = await readEntryDataHeader(reader, rawEntry);\n  if (!decompress) {\n    const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize, type);\n    if (isBlob(typedArrayOrBlob)) {\n      return typedArrayOrBlob;\n    }\n    return new Blob([isSharedArrayBuffer(typedArrayOrBlob.buffer) ? new Uint8Array(typedArrayOrBlob) : typedArrayOrBlob], {type});\n  }\n  // Here's the issue with this mess (should refactor?)\n  // if the source is a blob then we really want to pass a blob to inflateRawAsync to avoid a large\n  // copy if we're going to a worker.\n  const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize);\n  const result = await inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize, type);\n  return result;\n}\n\nfunction setOptions$1(options) {\n  setOptions(options);\n}\n\nasync function unzipRaw(source) {\n  let reader;\n  if (typeof Blob !== 'undefined' && source instanceof Blob) {\n    reader = new BlobReader(source);\n  } else if (source instanceof ArrayBuffer || (source && source.buffer && source.buffer instanceof ArrayBuffer)) {\n    reader = new ArrayBufferReader(source);\n  } else if (isSharedArrayBuffer(source) || isSharedArrayBuffer(source.buffer)) {\n    reader = new ArrayBufferReader(source);\n  } else if (typeof source === 'string') {\n    const req = await fetch(source);\n    if (!req.ok) {\n      throw new Error(`failed http request ${source}, status: ${req.status}: ${req.statusText}`);\n    }\n    const blob = await req.blob();\n    reader = new BlobReader(blob);\n  } else if (typeof source.getLength === 'function' && typeof source.read === 'function') {\n    reader = source;\n  } else {\n    throw new Error('unsupported source type');\n  }\n\n  const totalLength = await reader.getLength();\n\n  if (totalLength > Number.MAX_SAFE_INTEGER) {\n    throw new Error(`file too large. size: ${totalLength}. Only file sizes up 4503599627370496 bytes are supported`);\n  }\n\n  return await findEndOfCentralDirector(reader, totalLength);\n}\n\n// If the names are not utf8 you should use unzipitRaw\nasync function unzip(source) {\n  const {zip, entries} = await unzipRaw(source);\n  return {\n    zip,\n    entries: Object.fromEntries(entries.map(v => [v.name, v])),\n  };\n}\n\nfunction cleanup$1() {\n  cleanup();\n}\n\nexport { HTTPRangeReader, cleanup$1 as cleanup, setOptions$1 as setOptions, unzip, unzipRaw };\n"],"names":["readBlobAsArrayBuffer","blob","resolve","reject","reader","readBlobAsUint8Array","arrayBuffer","isBlob","v","isSharedArrayBuffer","b","isNode","isTypedArraySameAsArrayBuffer","typedArray","ArrayBufferReader","arrayBufferOrView","offset","length","BlobReader","type","inflate","data","buf","u8","bitsF","_bitsF","bitsE","_bitsE","decodeTiny","_decodeTiny","get17","_get17","noBuf","BFINAL","BTYPE","HLIT","HDIST","HCLEN","ML","MD","off","pos","lmap","dmap","p8","len","_check","U","i","tl","l","makeCodes","codes2map","mx0","_copyOut","mx1","code","lit","end","ebs","dcode","dlit","dbs","dst","bl","nbuf","LL","tree","ll","n","ni","src","mx","MAX_BITS","max_code","bits","bl_count","next_code","map","r15","cl","val","rest","i0","i1","p0","revCodes","imb","dt","u16","u32","x","pushV","tgt","sv","tab","c","k","inflateRaw","file","config","nextId","waitingForWorkerQueue","startWorker","url","worker","e","dynamicRequire","mod","request","Worker","fn","text","req","inflateRawLocal","uncompressedSize","processWaitingForWorkerQueue","inflateRawAsync","dosDateTimeToDate","date","time","day","month","year","millisecond","second","minute","hour","ZipEntry","rawEntry","readEntryDataAsBlob","readEntryDataAsArrayBuffer","buffer","decodeBuffer","EOCDR_WITHOUT_COMMENT_SIZE","MAX_COMMENT_SIZE","EOCDR_SIGNATURE","ZIP64_EOCDR_SIGNATURE","readAs","readAsBlobOrTypedArray","crc$1","getUint16LE","uint8View","getUint32LE","getUint64LE","utf8Decoder","isUTF8","findEndOfCentralDirector","totalLength","size","readStart","eocdr","diskNumber","entryCount","centralDirectorySize","centralDirectoryOffset","commentLength","expectedCommentLength","commentBytes","comment","readZip64CentralDirectory","readEntries","END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE","zip64EocdlOffset","eocdl","zip64EocdrOffset","zip64Eocdr","CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE","rawEntryCount","readEntryCursor","allEntriesBuffer","rawEntries","signature","fileCommentStart","extraFieldBuffer","headerId","dataSize","dataStart","dataEnd","zip64ExtraField","zip64EiefBuffer","index","nameField","expectedCompressedSize","readEntryDataHeader","fileNameLength","extraFieldLength","localFileHeaderEnd","decompress","fileDataStart","fileDataEnd","dataView","typedArrayOrBlob","unzipRaw","source","unzip","zip","entries"],"mappings":"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"}