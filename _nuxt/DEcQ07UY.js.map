{"version":3,"file":"DEcQ07UY.js","sources":["../../../../../../../assets/shared/battlescribe/github.ts"],"sourcesContent":["import type { Catalogue } from \"~/assets/shared/battlescribe/bs_main_catalogue\";\n\nimport type { BattleScribeRepoData } from \"~/assets/shared/battlescribe/bs_import_data\";\nimport { removePrefix, removeSuffix } from \"~/assets/shared/battlescribe/bs_helpers\";\nimport { XMLParser } from \"fast-xml-parser\";\nimport { unzip } from \"unzipit\";\n\nexport interface GithubIntegration {\n  githubUrl: string;\n  githubRepo?: string;\n  githubOwner?: string;\n  githubName?: string;\n  repoData?: BattleScribeRepoData;\n  discovered?: boolean;\n}\nconst headers = {\n  \"Accept\": \"application/vnd.github.v3+json\",\n  \"Content-type\": \"application/json; charset=UTF-8\"\n} as Record<string, string>;\nif (globalThis.process?.env?.githubToken) {\n  headers[\"Authorization\"] = `Bearer ${process.env.githubToken}`;\n}\nconst anonHeaders = {\n  \"Accept\": \"application/vnd.github.v3+json\",\n  \"Content-type\": \"application/json; charset=UTF-8\"\n} as Record<string, string>;\nif (globalThis.process?.env?.githubAnonToken) {\n  anonHeaders[\"Authorization\"] = `Bearer ${process.env.githubAnonToken}`;\n}\n\nfunction filename(path: string) {\n  const split = path.replaceAll(\"\\\\\", \"/\").split(\"/\");\n  return split[split.length - 1];\n}\n\nfunction throwIfError(response: { message?: string }) {\n  if (response.message) throw new Error(response.message);\n}\nexport function normalizeGithubRepoUrl(input: string): string | null {\n  const githubUrlRegex = /^(?:(http(?:s?)?:\\/\\/)?github.com\\/)?([^\\/]+)\\/([^\\/]+)\\/?.*$/;\n  const match = input.match(githubUrlRegex);\n\n  if (!match) {\n    return null;\n  }\n\n  const [, protocol = \"https://\", user, repo] = match;\n\n  if (!user || !repo) {\n    return null;\n  }\n  return `https://github.com/${user}/${repo}`;\n}\nexport function parseGitHubUrl(githubUrl: string) {\n  // Regular expression to match GitHub URLs\n  const githubUrlRegex = /^(?:https?:\\/\\/)?(?:www\\.)?github\\.com\\/([^/]+)\\/([^/]+)(?:\\/)?$/;\n\n  // Check if the input URL matches the GitHub URL format\n  const match = githubUrl.match(githubUrlRegex);\n\n  if (!match) {\n    throw new Error(\"Invalid GitHub URL format: \" + githubUrl);\n  }\n\n  const [, repoOwner, repoName] = match;\n\n  return {\n    githubUrl: githubUrl,\n    githubRepo: `${repoOwner}/${repoName}`,\n    githubOwner: repoOwner,\n    githubName: repoName,\n  };\n}\n\nasync function getFileContentFromRepo(githubUrl: string, filePath: string) {\n  try {\n    const urlParts = githubUrl.split(\"/\");\n    const owner = urlParts[urlParts.length - 2];\n    const repo = urlParts[urlParts.length - 1].replace(\".git\", \"\");\n    const url = `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(filePath)}`;\n\n    console.log(`Querying github api at ${url}`);\n    const response = await $fetch<{ download_url?: string }>(url, {\n      headers: {\n        \"User-Agent\": \"New Recruit Data Editor (Electron)\",\n        Accept: \"application/vnd.github.v3+json\",\n      },\n    });\n\n    if (!response || !response?.download_url) {\n      throw new Error(\"No download_url found\");\n    }\n    console.log(`Downloading file at ${response?.download_url}`);\n\n    const content = await $fetch<string>(response.download_url, {\n      headers: {\n        \"User-Agent\": \"New Recruit Data Editor (Electron)\",\n        Accept: \"application/vnd.github.v3+json\",\n      },\n    });\n    console.log(`Downloaded file, length: ${content.length}`);\n    return content;\n  } catch (error) {\n    throw error;\n  }\n}\nasync function getFileContentFromRepoWithFallback(githubUrl: string, filePath: string, fallBackPath?: string) {\n  try {\n    return await getFileContentFromRepo(githubUrl, filePath);\n  } catch (error) {\n    if (!fallBackPath) {\n      throw error;\n    }\n    return await getFileContentFromRepo(githubUrl, fallBackPath);\n  }\n}\n\nexport async function getNextRevision(github: GithubIntegration, catalogue: Catalogue) {\n  if (catalogue.fullFilePath) {\n    try {\n      const fileName = filename(catalogue.fullFilePath);\n      const fallBack = fileName.endsWith(\"z\") ? removeSuffix(fileName, \"z\") : undefined;\n      const content = await getFileContentFromRepoWithFallback(github.githubUrl, fileName, fallBack);\n      const regex = /revision=\"(\\d+)\"/;\n      const match = content.match(regex);\n      if (match) {\n        const resultRevision = (Number(match[1]) || 0) + 1;\n        console.log(`Revision of ${catalogue.name}: ${catalogue.revision} -> ${resultRevision}`);\n        return resultRevision;\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  }\n  return catalogue.revision || 1;\n}\nexport async function fetchRef(\n  owner: string,\n  repo: string,\n  ref: string,\n): Promise<{ ref: string | null; sha?: string; name?: string; date?: string }> {\n  switch (ref) {\n    case \"latest-commit\": {\n      const { sha } = await getTree(owner, repo, \"HEAD\");\n      return { ref: sha, sha: sha };\n    }\n    case \"latest-tag\":\n    case \"TAG_HEAD\": {\n      const tagsResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/tags`, { headers });\n      const tags = await tagsResponse.json();\n      throwIfError(tags);\n      const latestTagSha = tags[0]?.commit?.sha;\n      if (!latestTagSha) {\n        throw new Error(\"Repo has no releases/tags, use latest commit (Head)\");\n      }\n      return { ref: tags[0].name, name: tags[0].name, sha: latestTagSha };\n    }\n    case \"latest-release-or-commit\": {\n      const releaseResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/releases/latest`, { headers });\n      if (releaseResponse.status !== 404) {\n        const release = await releaseResponse.json();\n        throwIfError(release);\n        const tag = release.tag_name;\n        return { ref: tag, name: tag, date: release.published_at };\n      }\n      const { sha } = await getTree(owner, repo, \"HEAD\");\n      return { ref: sha, sha };\n    }\n    case \"latest-release-atom\": {\n      const atomResponse = await fetch(`https://github.com/${owner}/${repo}/releases.atom`);\n      const atomXml = await atomResponse.text();\n      function parseValue(str: string): any {\n        switch (str) {\n          case \"true\":\n            return true;\n          case \"false\":\n            return false;\n          default:\n            if (isNaN(str as any)) return str;\n            const float = parseFloat(str);\n            if (isFinite(float) && str.includes(\"+\") == false) return float;\n            return str;\n        }\n      }\n      const options = {\n        allowBooleanAttributes: true,\n        ignoreAttributes: false,\n        attributeNamePrefix: \"\",\n        textNodeName: \"$text\",\n        processEntities: false,\n        parseTagValue: false,\n        ignoreDeclaration: true,\n        alwaysCreateTextNode: false,\n        trimValues: false,\n        isArray: (tagName: string, jPath: string, isLeafNode: boolean, isAttribute: boolean) => {\n          return !isAttribute && [\"entry\", \"link\"].includes(tagName);\n        },\n        attributeValueProcessor: (name: string, val: string) => {\n          return parseValue(unescape(val));\n        },\n        tagValueProcessor: (name: string, val: string) => {\n          return unescape(val).trim();\n        },\n      };\n      const parsed = new XMLParser(options).parse(atomXml);\n      if (!parsed.feed?.entry?.length) {\n        return { ref: null };\n      } else {\n        const entry = parsed.feed.entry[0];\n        const tag = entry.id.split(\"/\").pop();\n        return { ref: tag, name: tag };\n      }\n    }\n    case \"latest-release\":\n    case \"RELEASE_HEAD\":\n      const releaseResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/releases/latest`, { headers });\n      const release = await releaseResponse.json();\n      throwIfError(release);\n      const tag = release.tag_name;\n      return { ref: tag, name: tag, date: release.published_at };\n    default:\n      return { ref: ref };\n  }\n}\nexport async function getBlob(url: string,): Promise<string> {\n  const resp = await fetch(url, { headers: { ...headers, Accept: \"application/vnd.github.raw+json\" } });\n  if (!resp.ok) throw new Error(`Failed to fetch blob: ${resp.status}, url: ${url}`);\n  const text = await resp.text();\n  return text;\n}\nexport async function getRawBlob(url: string): Promise<Blob> {\n  const resp = await fetch(url, { headers: { ...headers, Accept: \"application/vnd.github.raw+json\" } });\n  if (!resp.ok) throw new Error(`Failed to fetch blob: ${resp.status}, url: ${url}`);\n  const text = await resp.blob();\n  return text;\n}\nexport async function getCommit(owner: string, repo: string, sha: string) {\n  const resp = await fetch(`https://api.github.com/repos/${owner}/${repo}/commits/${sha}`, { headers });\n  const json = await resp.json();\n  throwIfError(json);\n  return json;\n}\nexport async function getCommitDate(owner: string, repo: string, sha: string) {\n  const resp = await fetch(`https://api.github.com/repos/${owner}/${repo}/commits/${sha}`, { headers });\n  const json = await resp.json();\n  throwIfError(json);\n  return json.commit.committer.date;\n}\nexport async function getLatestCommitDate(\n  owner: string,\n  repo: string,\n  path: string,\n  commitSha: string,\n  blobSha: string,\n) {\n  const apiUrlBase = `https://api.github.com/repos/${owner}/${repo}`;\n\n  try {\n    // List commits affecting the file up to the commit resolved from the tag\n    const response = await fetch(`${apiUrlBase}/commits?path=${path}&sha=${commitSha}`, { headers });\n    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);\n    const commits = await response.json();\n    throwIfError(commits);\n\n    // Check each commit for the blob SHA (This part is not fully implemented here)\n    for (let commit of commits) {\n      let commitResponse = await fetch(`${apiUrlBase}/git/trees/${commit.sha}`, { headers });\n      if (!commitResponse.ok) continue; // Skip on error\n      let commitData = await commitResponse.json();\n      throwIfError(commitData);\n\n      // You would need to traverse the tree to find the file and check its blob SHA\n      // This part is simplified and needs proper tree traversal depending on repository structure\n      if (\n        commitData.tree.some((entry: { path?: string; sha?: string }) => entry.path === path && entry.sha === blobSha)\n      ) {\n        return commit.commit.committer.date;\n      }\n    }\n    return \"No matching commit found\";\n  } catch (error) {\n    console.error(\"Error fetching commit data:\", error);\n    return null;\n  }\n}\n\nexport interface GitTreeFile {\n  path?: string;\n  mode?: string;\n  type?: string;\n  sha?: string;\n  size?: number;\n  url?: string;\n  content?: string;\n}\n\nexport interface GitTree {\n  sha: string;\n  url: string;\n  truncated: boolean;\n  tree: GitTreeFile[];\n}\n\nexport async function getTree(owner: string, repo: string, ref: string): Promise<GitTree> {\n  const treeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees/${ref}`, { headers });\n  const tree = await treeResponse.json();\n  throwIfError(tree);\n  return tree;\n}\n\nexport async function starAndWatchRepo(owner: string, repo: string) {\n  // Star the repository\n  try {\n    const response = await fetch(`https://api.github.com/user/starred/${owner}/${repo}`, {\n      method: \"PUT\",\n      headers,\n    });\n    if (response.status !== 204) {\n      const json = await response.json();\n      throwIfError(json);\n    }\n  } catch (error) {\n    console.error(`Failed to star the repository ${owner}/${repo}:`, error);\n  }\n\n  // Watch the repository\n  try {\n    const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/subscription`, {\n      method: \"PUT\",\n      headers,\n      body: JSON.stringify({\n        subscribed: true,\n        ignored: false,\n      }),\n    });\n    const json = await response.json();\n    throwIfError(json);\n  } catch (error) {\n    console.error(`Failed to watch the repository ${owner}/${repo}:`, error);\n  }\n}\n\nexport interface GithubNotification {\n  repository: {\n    name: string;\n    full_name: string;\n    owner: {\n      login: string;\n    };\n  };\n  subject: {\n    title: string;\n    type: string;\n  };\n  reason: string;\n  unread: boolean;\n  updated_at: string;\n  last_read_at: string;\n  x_poll_interval?: number;\n}\n\nconst NOT_MODIFIED = 304;\nconst SUCCESS = 200;\nexport async function getNotifications(since?: Date) {\n  const sinceString = since ? since.toISOString() : undefined;\n\n  const notificationHeaders = {} as Record<string, string>;\n  const params = [] as string[];\n  if (sinceString) {\n    notificationHeaders[\"If-Modified-Since\"] = sinceString;\n    params.push(`since=${encodeURIComponent(sinceString)}`);\n    params.push(`all=true`);\n  } else {\n    params.push(`all=false`);\n  }\n  const query = params.length ? `?${params.join(\"&\")}` : \"\";\n  const response = await fetch(`https://api.github.com/notifications${query}`, {\n    headers: { ...headers, ...notificationHeaders },\n  });\n  const x_poll_interval = response.headers.get(\"X-Poll-Interval\")\n    ? Number(response.headers.get(\"X-Poll-Interval\"))\n    : null;\n  if (response.status === NOT_MODIFIED) {\n    return {\n      notifications: [],\n      x_poll_interval,\n    }\n  }\n  const last_modified = new Date(response.headers.get(\"Last-Modified\")!);\n  const json = await response.json();\n  throwIfError(json);\n  if (response.status === SUCCESS) {\n    if ((json as GithubNotification[]).length) {\n      try {\n        const mark_as_read_response = await fetch(`https://api.github.com/notifications`, {\n          headers,\n          method: \"PUT\",\n          body: JSON.stringify({ last_read_at: new Date().toISOString(), read: true })\n        })\n      } catch (e) {\n        console.error(\"Error in github.ts:getNotifications()\", e);\n      }\n    }\n  }\n  return {\n    notifications: json as GithubNotification[],\n    x_poll_interval,\n    last_modified,\n  };\n}\nexport class DynamicPoller {\n  private interval: number;\n  private timerId?: NodeJS.Timeout;\n  private isPolling: boolean = false;\n\n  constructor(initialInterval: number) {\n    this.interval = initialInterval;\n  }\n\n  // Method to start the polling\n  start(task: () => Promise<number | null | void | undefined>): void {\n    if (this.isPolling) {\n      this.stop();\n    }\n    this.isPolling = true;\n    const executeTask = async () => {\n      try {\n        const newInterval = await task();\n        if (typeof newInterval === \"number\") this.interval = newInterval;\n      } catch (error) {\n      } finally {\n        if (this.isPolling) {\n          this.timerId = setTimeout(executeTask, this.interval);\n        }\n      }\n    };\n    executeTask();\n  }\n\n  stop(): void {\n    if (this.timerId) {\n      clearTimeout(this.timerId);\n      this.timerId = undefined;\n    }\n    this.isPolling = false;\n  }\n}\n\nexport async function getRepoZip(owner: string, name: string, ref: string = \"HEAD\") {\n  // const tagUrl = `https://codeload.github.com/${owner}/${name}/legacy.zip/refs/tags/${ref}`\n  // const headUrl = `https://codeload.github.com/${owner}/${name}/legacy.zip/refs/heads/${ref}`\n  const tagUrl = `https://api.github.com/repos/${owner}/${name}/zipball/${ref}`\n  const headUrl = `https://api.github.com/repos/${owner}/${name}/zipball/${ref}`\n\n\n  let zipFile: Blob;\n  try {\n    zipFile = await $fetch<Blob>(`https://www.newrecruit.eu/api/proxy?url=${encodeURIComponent(tagUrl)}`)\n  }\n  catch (e) {\n    zipFile = await $fetch<Blob>(`https://www.newrecruit.eu/api/proxy?url=${encodeURIComponent(headUrl)}`)\n  }\n  // Extract the useful files\n  const folder = await unzip(zipFile);\n  const entries = Object.entries(folder.entries)\n  const root = entries[0][0]\n  const result = entries.map(([k, v]) => [removePrefix(k, root), v]) as typeof entries\n  return result\n}\n\n\nexport async function createAnonymousIssue(repo: string, data: { title: string, body: string }) {\n  const resp = await fetch(`https://api.github.com/repos/${repo}/issues`, {\n    headers: anonHeaders,\n    method: \"POST\",\n    body: JSON.stringify({ ...data, title: `[Anon] ${data.title}` })\n  })\n  return await resp.json()\n}\n\n\nexport async function proxyGithubReq(url: string, headers = {}) {\n  const resp = await fetch(url, { headers: { Authorization: anonHeaders.Authorization, ...headers } })\n  const result = await resp\n  return result;\n}"],"names":["normalizeGithubRepoUrl","input","githubUrlRegex","match","protocol","user","repo","parseGitHubUrl","githubUrl","repoOwner","repoName","getRepoZip","owner","name","ref","tagUrl","headUrl","zipFile","folder","unzip","entries","root","k","v","removePrefix"],"mappings":"oEAsCO,SAASA,EAAuBC,EAA8B,CACnE,MAAMC,EAAiB,gEACjBC,EAAQF,EAAM,MAAMC,CAAc,EAExC,GAAI,CAACC,EACH,OAAO,KAGT,KAAM,CAAA,CAAGC,EAAW,WAAYC,EAAMC,CAAI,EAAIH,EAE9C,MAAI,CAACE,GAAQ,CAACC,EACL,KAEF,sBAAsBD,CAAI,IAAIC,CAAI,EAC3C,CACO,SAASC,EAAeC,EAAmB,CAEhD,MAAMN,EAAiB,mEAGjBC,EAAQK,EAAU,MAAMN,CAAc,EAE5C,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,8BAAgCK,CAAS,EAG3D,KAAM,CAAA,CAAGC,EAAWC,CAAQ,EAAIP,EAEhC,MAAO,CACL,UAAAK,EACA,WAAY,GAAGC,CAAS,IAAIC,CAAQ,GACpC,YAAaD,EACb,WAAYC,CAAA,CAEhB,CAwXA,eAAsBC,EAAWC,EAAeC,EAAcC,EAAc,OAAQ,CAGlF,MAAMC,EAAS,gCAAgCH,CAAK,IAAIC,CAAI,YAAYC,CAAG,GACrEE,EAAU,gCAAgCJ,CAAK,IAAIC,CAAI,YAAYC,CAAG,GAG5E,IAAIG,EACJ,GAAI,CACFA,EAAU,MAAM,OAAa,2CAA2C,mBAAmBF,CAAM,CAAC,EAAE,CACtG,MACU,CACRE,EAAU,MAAM,OAAa,2CAA2C,mBAAmBD,CAAO,CAAC,EAAE,CACvG,CAEA,MAAME,EAAS,MAAMC,EAAMF,CAAO,EAC5BG,EAAU,OAAO,QAAQF,EAAO,OAAO,EACvCG,EAAOD,EAAQ,CAAC,EAAE,CAAC,EAEzB,OADeA,EAAQ,IAAI,CAAC,CAACE,EAAGC,CAAC,IAAM,CAACC,EAAaF,EAAGD,CAAI,EAAGE,CAAC,CAAC,CAEnE"}