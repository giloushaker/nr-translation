const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./C1nbJLsP.js","./esT4bswo.js","./entry.Dr0sCHZ6.css"])))=>i.map(i=>d[i]);
import{W as y,S as w}from"./esT4bswo.js";class b{constructor(e){this.file=e}async fetchTranslations(e,t){const a=await this.file.text();try{return this.file.name.endsWith(".json")?this.parseJsonFile(a):this.file.name.endsWith(".po")?this.parsePoFile(a):this.file.name.endsWith(".csv")?this.parseCsvFile(a):this.parseJsonFile(a)}catch(s){throw new Error(`Failed to parse file: ${s.message}`)}}parseJsonFile(e){const t=JSON.parse(e);if(t.translations&&Array.isArray(t.translations))return t.translations;if(typeof t=="object")return Object.entries(t).map(([a,s])=>({id:"",key:a,original:a,translation:s,translated:!0,catalogue:"imported",modified:!1}));throw new Error("Unrecognized JSON format")}parsePoFile(e){const t=[],a=e.split(`
`);let s={};for(const n of a){const r=n.trim();r.startsWith("msgid ")?(s.msgid&&s.msgstr&&t.push({id:"",key:s.msgid,original:s.msgid,translation:s.msgstr,translated:!!s.msgstr,catalogue:"imported",modified:!1}),s={msgid:r.slice(7,-1)}):r.startsWith("msgstr ")&&(s.msgstr=r.slice(8,-1))}return s.msgid&&s.msgstr&&t.push({id:"",key:s.msgid,original:s.msgid,translation:s.msgstr,translated:!!s.msgstr,catalogue:"imported",modified:!1}),t}parseCsvFile(e){const t=e.split(`
`),a=[],s=t[0]?.includes("Original")?1:0;for(let n=s;n<t.length;n++){const r=t[n]?.trim();if(!r)continue;const i=this.parseCsvLine(r);i.length>=2&&a.push({id:"",key:i[0],original:i[0],translation:i[1],translated:!!i[1],catalogue:i[2]||"imported",modified:!1})}return a}parseCsvLine(e){const t=[];let a="",s=!1;for(let n=0;n<e.length;n++){const r=e[n];r==='"'?s&&e[n+1]==='"'?(a+='"',n++):s=!s:r===","&&!s?(t.push(a),a=""):a+=r}return t.push(a),t}async uploadTranslations(e,t,a){throw new Error("File backend does not support uploading")}isAvailable(){return!0}async getStats(e){return null}}class g{static REPO_OWNER="NewRecruitEU";static REPO_NAME="translations";static createIssueUrl(e,t,a){const s=`Translation update: ${e} - ${t}`,n={system:e,language:t,timestamp:new Date().toISOString(),translations:a.map(l=>({key:l.key,original:l.original,translation:l.translation,catalogue:l.catalogue}))},r=`## Translation Submission

**System:** ${e}
**Language:** ${t}
**Translated:** ${a.filter(l=>l.translated).length}/${a.length}

### Translation Data
\`\`\`json
${JSON.stringify(n,null,2)}
\`\`\`

---
*This issue was created by the translation tool. A maintainer will review and create a PR.*`,i=new URLSearchParams({title:s,body:r,labels:"translation-update,automated"});return`https://github.com/${this.REPO_OWNER}/${this.REPO_NAME}/issues/new?${i}`}static generatePRInstructions(e,t,a){return`# How to submit your translations

1. **Fork the repository:**
   https://github.com/${this.REPO_OWNER}/${this.REPO_NAME}/fork

2. **Create/update this file in your fork:**
   Path: \`${e}/${t}/translations.json\`

3. **Paste this content:**
\`\`\`json
${a}
\`\`\`

4. **Create a Pull Request:**
   - Go to: https://github.com/${this.REPO_OWNER}/${this.REPO_NAME}/pulls
   - Click "New pull request"
   - Click "compare across forks"
   - Select your fork
   - Create the PR with title: "Update ${t} translations for ${e}"

Your translations will be reviewed and merged by a maintainer.`}static createDirectEditUrl(e,t,a){const s=`${e}/${t}/translations.json`,n=`Update ${t} translations for ${e}`,r=`Updated translation file with new/modified translations.

This PR was created using the NR Translation Tool.`,i=new URLSearchParams({filename:s,value:a,message:n,description:r,target_branch:"main"});return`https://github.com/${this.REPO_OWNER}/${this.REPO_NAME}/new/main?${i}`}}class k{owner="NewRecruitEU";repo="translations";apiBase="https://api.github.com";constructor(){}async fetchTranslations(e,t){try{const a=`${e}/${t}/translations.json`,s=`${this.apiBase}/repos/${this.owner}/${this.repo}/contents/${a}`,n=await fetch(s,{headers:this.getHeaders()});if(n.status===404)return[];if(!n.ok)throw new Error(`Failed to fetch translations: ${n.status} ${n.statusText}`);const r=await n.json(),i=this.base64ToUtf8(r.content);return JSON.parse(i).translations.map(d=>({id:`${d.key}-${d.catalogue}`,key:d.key,original:d.original,translation:d.translation,translated:d.translated,catalogue:d.catalogue,modified:!1}))}catch(a){throw console.error("Error fetching translations from GitHub:",a),a}}async uploadTranslations(e,t,a){try{const s=await this.fetchTranslations(e,t),n=new Map(s.map(c=>[c.key,c])),r=new Map(n);a.forEach(c=>{(c.modified||c.translated)&&r.set(c.key,c)});const i=Array.from(r.values()).sort((c,f)=>c.key.localeCompare(f.key)),l={meta:{system:e,language:t,languageName:t,exportDate:new Date().toISOString(),totalStrings:i.length},translations:i.map(c=>({key:c.key,original:c.original,translation:c.translation,translated:c.translated,catalogue:c.catalogue}))},d=JSON.stringify(l,null,2),u=`${e}/${t}/translations.json`;let h=!1;try{const c=`${this.apiBase}/repos/${this.owner}/${this.repo}/contents/${u}`;h=(await fetch(c,{headers:this.getHeaders()})).ok}catch{h=!1}if(h){const c=g.createIssueUrl(e,t,i);window.open(c,"_blank"),alert("Since the translation file already exists, we've opened a GitHub issue with your merged translations. A maintainer will review and create a PR with your changes.")}else{const c=g.createDirectEditUrl(e,t,d);window.open(c,"_blank"),alert("Opening GitHub to create a new translation file. GitHub will guide you through creating a PR.")}}catch(s){throw console.error("Error preparing translations for upload:",s),new Error("Failed to prepare translations. Please try again.")}}isAvailable(){return!0}async getStats(e){try{const t=e,a=`${this.apiBase}/repos/${this.owner}/${this.repo}/contents/${t}`,s=await fetch(a,{headers:this.getHeaders()});if(s.status===404)return{languages:[]};if(!s.ok)throw new Error(`Failed to fetch stats: ${s.status} ${s.statusText}`);const r=(await s.json()).filter(l=>l.type==="dir"),i={languages:[]};for(const l of r)try{const d=await this.fetchTranslations(e,l.name),u=d.filter(h=>h.translated).length;i.languages.push({code:l.name,translatedCount:u,totalCount:d.length,lastUpdated:new Date().toISOString()})}catch(d){console.warn(`Failed to fetch stats for ${l.name}:`,d)}return i}catch(t){return console.error("Error fetching stats from GitHub:",t),{languages:[]}}}getHeaders(){return{Accept:"application/vnd.github.v3+json"}}base64ToUtf8(e){const t=e.replace(/\s/g,""),a=atob(t),s=new Uint8Array(a.length);for(let n=0;n<a.length;n++)s[n]=a.charCodeAt(n);return new TextDecoder("utf-8").decode(s)}}const $=y("translation",{state:()=>({strings:{},catalogues:[],translations:[],isLoaded:!1,currentSystemId:null,totalStrings:0,translatedCount:0,backend:new k,translationSource:null,isSyncing:!1,isSubmitting:!1,lastSyncTime:null,lastSubmitTime:null}),getters:{systemStringCount:o=>o.totalStrings,systemName:o=>o.translationSource?.getName()||"Unknown System",getCatalogueById:o=>e=>o.catalogues.find(t=>t.id===e),getTranslationByKey:o=>e=>o.translations.find(t=>t.key===e),getTranslationsByStatus:o=>e=>o.translations.filter(t=>t.translated===e),canSync:o=>o.backend.isAvailable()&&!o.isSyncing,canSubmit:o=>o.backend.isAvailable()&&!o.isSubmitting},actions:{getStorageKey(o,e){return`${o}-${e}`},async dbOpen(){return new Promise((o,e)=>{const t=indexedDB.open("nr-translations",2);t.onerror=()=>e(t.error),t.onsuccess=()=>o(t.result),t.onupgradeneeded=a=>{const s=a.target.result;s.objectStoreNames.contains("translations")&&s.deleteObjectStore("translations");const n=s.createObjectStore("translations",{keyPath:"compositeKey"});n.createIndex("systemLanguage","systemLanguage",{unique:!1}),n.createIndex("systemId","systemId",{unique:!1})}})},async dbPutRecord(o){const a=(await this.dbOpen()).transaction(["translations"],"readwrite").objectStore("translations");return new Promise((s,n)=>{const r=a.put(o);r.onsuccess=()=>s(),r.onerror=()=>n(r.error)})},async dbGetByIndex(o,e){const n=(await this.dbOpen()).transaction(["translations"],"readonly").objectStore("translations").index(o);return new Promise((r,i)=>{const l=[],d=n.openCursor(IDBKeyRange.only(e));d.onsuccess=u=>{const h=u.target.result;h?(l.push(h.value),h.continue()):r(l)},d.onerror=()=>i(d.error)})},async dbDeleteByIndex(o,e){const n=(await this.dbOpen()).transaction(["translations"],"readwrite").objectStore("translations").index(o);return new Promise((r,i)=>{const l=n.openCursor(IDBKeyRange.only(e));l.onsuccess=d=>{const u=d.target.result;u?(u.delete(),u.continue()):r()},l.onerror=()=>i(l.error)})},async dbDeleteByCompositeKey(o){const a=(await this.dbOpen()).transaction(["translations"],"readwrite").objectStore("translations");return new Promise((s,n)=>{const r=a.delete(o);r.onsuccess=()=>s(),r.onerror=()=>n(r.error)})},async saveTranslationsToLocal(o,e,t){const a=`${o}-${e}`;try{if(t&&t.length>0)for(const s of t)if(s.translated){const n={compositeKey:`${o}-${e}-${s.key}`,systemId:o,languageCode:e,systemLanguage:a,key:s.key,translation:s.translation,catalogue:s.catalogue,modified:s.modified,lastSaved:Date.now()};await this.dbPutRecord(n)}else await this.dbDeleteByCompositeKey(`${o}-${e}-${s.key}`);else{await this.dbDeleteByIndex("systemLanguage",a);const s=this.translations.filter(n=>n.translated);for(const n of s){const r={compositeKey:`${o}-${e}-${n.key}`,systemId:o,languageCode:e,systemLanguage:a,key:n.key,translation:n.translation,catalogue:n.catalogue,modified:n.modified,lastSaved:Date.now()};await this.dbPutRecord(r)}}}catch(s){console.warn("Failed to save translations to IndexedDB:",s)}},async loadTranslationsFromLocal(o,e){const t=`${o}-${e}`;try{const a=await this.dbGetByIndex("systemLanguage",t);if(a.length===0)return!1;const s=new Map(this.translations.map(r=>[r.key,r]));a.forEach(r=>{const i=s.get(r.key);i&&(i.translation=r.translation||"",i.translated=!0,i.modified=r.modified||!1)});const n=new Map(this.translations.map(r=>[r.key,r]));return this.catalogues.forEach(r=>{r.strings.forEach(i=>{const l=n.get(i.key);l&&(i.translation=l.translation,i.translated=l.translated,i.modified=l.modified)})}),this.translatedCount=this.translations.filter(r=>r.translated).length,!0}catch(a){return console.warn("Failed to load translations from IndexedDB:",a),!1}},async clearLocalTranslations(o,e){const t=`${o}-${e}`;try{await this.dbDeleteByIndex("systemLanguage",t)}catch(a){console.warn("Failed to clear translations from IndexedDB:",a)}},async loadTranslationsFromSource(o,e,t){const a=o.getId();if(!(this.isLoaded&&this.currentSystemId===a))try{this.translationSource=o,this.currentSystemId=a;const{strings:s,catalogues:n,translations:r}=await this.translationSource.getTranslations(e||"en",t);this.strings=s,globalThis.strings=s,this.catalogues=n,this.translations=r,globalThis.translations=r,this.totalStrings=r.length,this.translatedCount=r.filter(i=>i.translated).length,this.isLoaded=!0,this.translationSource=o,e&&await this.loadTranslationsFromLocal(a,e)}catch(s){throw console.error("Failed to load translations:",s),s}},async ensureTranslationsLoaded(o,e,t){if(this.isLoaded&&this.currentSystemId===o)return;this.clearCache();const{createTranslationSourceForSystem:a}=await w(async()=>{const{createTranslationSourceForSystem:n}=await import("./C1nbJLsP.js");return{createTranslationSourceForSystem:n}},__vite__mapDeps([0,1,2]),import.meta.url),s=a(o);await this.loadTranslationsFromSource(s,e,t),this.currentSystemId=o},updateTranslation(o,e,t,a){const s=this.translations.find(n=>n.id===o);if(s){s.translation=e,s.modified=!0,s.translated=e.trim()!=="",this.translatedCount=this.translations.filter(r=>r.translated).length;const n=this.catalogues.find(r=>r.id===s.catalogue);if(n){const r=n.strings.find(i=>i.id===o);r&&(r.translation=e,r.modified=!0,r.translated=s.translated)}t&&a&&this.saveTranslationsToLocal(t,a,[s])}},clearCache(){this.strings={},this.catalogues=[],this.translations=[],this.isLoaded=!1,this.currentSystemId=null,this.translationSource=null,this.totalStrings=0,this.translatedCount=0,globalThis.strings={},globalThis.translations=[]},setBackend(o){this.backend=o},getCurrentTranslationSource(){return this.translationSource},async syncFromFile(o,e,t,a="ask-user"){const n=await new b(o).fetchTranslations(e,t);return await this.syncTranslations(n,e,t,a)},async syncFromBackend(o,e,t="ask-user"){if(!this.backend.isAvailable())throw new Error("No backend configured");const a=await this.backend.fetchTranslations(o,e);return await this.syncTranslations(a,o,e,t)},async syncTranslations(o,e,t,a="ask-user"){if(this.isSyncing)throw new Error("Sync already in progress");this.isSyncing=!0;try{if(o.length===0)return this.lastSyncTime=Date.now(),{conflicts:[]};const s=new Map(this.translations.map(i=>[i.key,i])),n=[],r=[];if(o.forEach(i=>{const l=s.get(i.key);l&&(l.modified&&l.translation!==i.translation&&l.translation.trim()!==""&&i.translation.trim()!==""?n.push({key:i.key,original:l.original,local:l.translation,server:i.translation}):r.push({local:l,server:i}))}),r.forEach(({local:i,server:l})=>{i.translation=l.translation,i.translated=l.translated,i.modified=!1}),n.length>0){if(a==="server-wins")n.forEach(i=>{const l=s.get(i.key);l&&(l.translation=i.server,l.translated=!0,l.modified=!1)});else if(a!=="client-wins"){if(a==="ask-user")return{conflicts:n}}}return this.updateCataloguesFromTranslations(),this.translatedCount=this.translations.filter(i=>i.translated).length,await this.saveTranslationsToLocal(e,t),this.lastSyncTime=Date.now(),{conflicts:a==="ask-user"?n:[]}}finally{this.isSyncing=!1}},updateCataloguesFromTranslations(){const o=new Map(this.translations.map(e=>[e.key,e]));this.catalogues.forEach(e=>{e.strings.forEach(t=>{const a=o.get(t.key);a&&(t.translation=a.translation,t.translated=a.translated,t.modified=a.modified)})})},resolveConflicts(o){const e=new Map(this.translations.map(t=>[t.key,t]));o.forEach(t=>{const a=e.get(t.key);a&&t.choice==="server"&&(a.translation=t.server,a.translated=!0,a.modified=!1)}),this.updateCataloguesFromTranslations(),this.translatedCount=this.translations.filter(t=>t.translated).length},async submitToBackend(o,e,t=!0){if(!this.backend.isAvailable())throw new Error("No backend configured");if(this.isSubmitting)throw new Error("Submit already in progress");this.isSubmitting=!0;try{let a=this.translations.filter(s=>s.translated&&s.translation.trim()!=="");if(t&&(a=a.filter(s=>s.modified)),a.length>0){await this.backend.uploadTranslations(o,e,a),a.forEach(n=>{n.modified=!1});const s=new Map(this.translations.map(n=>[n.key,n]));this.catalogues.forEach(n=>{n.strings.forEach(r=>{const i=s.get(r.key);i&&(r.modified=i.modified)})}),await this.saveTranslationsToLocal(o,e)}this.lastSubmitTime=Date.now()}finally{this.isSubmitting=!1}},exportTranslations(o,e,t,a,s=!1,n=!1){let r=this.translations;s?r=this.translations.filter(u=>u.translated):n&&(r=this.translations.filter(u=>!u.translated));let i="",l=`${a}_${e}_translations`,d="";switch(o){case"json":const u={meta:{system:a,language:e,languageName:t,exportDate:new Date().toISOString(),totalStrings:r.length},translations:r.map(c=>({key:c.key,original:c.original,translation:c.translation||"",translated:c.translated,catalogue:c.catalogue}))};i=JSON.stringify(u,null,2),l+=".json",d="application/json";break;case"json-kv":const h=r.filter(c=>c.translated&&c.original!==c.translation).reduce((c,f)=>(c[f.key]=f.translation,c),{});i=JSON.stringify(h,null,2),l+="_kv.json",d="application/json";break;case"csv":i=`Original,Translation,Catalogue,Status
`,r.forEach(c=>{const f=c.original.replace(/"/g,'""'),m=(c.translation||"").replace(/"/g,'""'),p=c.translated?"translated":"untranslated";i+=`"${f}","${m}","${c.catalogue}","${p}"
`}),l+=".csv",d="text/csv";break;case"po":i=`# Translations for ${a}
`,i+=`# Language: ${t}
`,i+=`msgid ""
`,i+=`msgstr ""
`,i+=`"Content-Type: text/plain; charset=UTF-8\\n"
`,i+=`"Language: ${e}\\n"

`,r.forEach(c=>{i+=`#: ${c.catalogue}
`,i+=`msgid "${c.original.replace(/"/g,'\\"')}"
`,i+=`msgstr "${(c.translation||"").replace(/"/g,'\\"')}"

`}),l+=".po",d="text/plain";break}return{content:i,filename:l,mimeType:d}},downloadExport(o,e,t,a,s=!1,n=!1){const{content:r,filename:i,mimeType:l}=this.exportTranslations(o,e,t,a,s,n),d=new Blob([r],{type:l}),u=URL.createObjectURL(d),h=document.createElement("a");h.href=u,h.download=i,document.body.appendChild(h),h.click(),document.body.removeChild(h),URL.revokeObjectURL(u)}}});export{$ as u};
//# sourceMappingURL=D7ewN1DE.js.map
