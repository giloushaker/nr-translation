{"version":3,"mappings":"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","names":["NoOpBackend","systemId","languageCode","translations","FileBackend","file","text","error","data","key","translation","lines","currentEntry","line","trimmed","startIndex","i","columns","result","current","inQuotes","char","useTranslationStore","defineStore","state","catalogueId","cat","translated","resolve","reject","request","event","db","store","record","indexName","value","index","results","cursor","translatedStrings","t","systemLanguageKey","savedTranslations","translationMap","savedTranslation","keyMap","catalogue","string","s","translationSource","progressCallback","sourceId","rawStrings","catalogueList","allTranslations","createTranslationSourceForSystem","__vitePreload","source","stringId","translationObj","catString","backend","strategy","backendTranslations","conflicts","safeUpdates","serverTranslation","local","server","conflict","onlyModified","translationsToSubmit","format","languageName","systemName","onlyTranslated","onlyUntranslated","dataToExport","content","filename","mimeType","jsonData","kvData","acc","original","status","blob","url","link"],"ignoreList":[],"sources":["../../../../../../../stores/translationBackends/NoOpBackend.ts","../../../../../../../stores/translationBackends/FileBackend.ts","../../../../../../../stores/translationStore.ts"],"sourcesContent":["import type { TranslationString } from \"../translationStore\";\nimport type { TranslationBackend } from \"./index\";\n\n// Default no-op backend implementation\nexport class NoOpBackend implements TranslationBackend {\n  getSystems(): Promise<Array<{ name: string; description: string; id: string; }>> {\n    throw new Error(\"Method not implemented.\");\n  }\n  \n  getStats(systemId: string): Promise<any> {\n    throw new Error(\"Method not implemented.\");\n  }\n  \n  async sync(systemId: string, languageCode: string): Promise<TranslationString[]> {\n    return [];\n  }\n\n  async submit(systemId: string, languageCode: string, translations: TranslationString[]): Promise<void> {\n    // No-op\n  }\n\n  isAvailable(): boolean {\n    return false;\n  }\n}","import type { TranslationString } from \"../translationStore\";\nimport type { TranslationBackend } from \"./index\";\n\n// File-based backend implementation\nexport class FileBackend implements TranslationBackend {\n  constructor(private file: File) {}\n\n  async sync(systemId: string, languageCode: string): Promise<TranslationString[]> {\n    const text = await this.file.text();\n\n    try {\n      // Try parsing as JSON first\n      if (this.file.name.endsWith('.json')) {\n        return this.parseJsonFile(text);\n      } else if (this.file.name.endsWith('.po')) {\n        return this.parsePoFile(text);\n      } else if (this.file.name.endsWith('.csv')) {\n        return this.parseCsvFile(text);\n      } else {\n        // Try to auto-detect format\n        return this.parseJsonFile(text);\n      }\n    } catch (error) {\n      throw new Error(`Failed to parse file: ${error.message}`);\n    }\n  }\n\n  private parseJsonFile(text: string): TranslationString[] {\n    const data = JSON.parse(text);\n\n    if (data.translations && Array.isArray(data.translations)) {\n      // Full JSON format\n      return data.translations;\n    } else if (typeof data === 'object') {\n      // Key-value JSON format\n      return Object.entries(data).map(([key, translation]) => ({\n        id: '',\n        key,\n        original: key,\n        translation: translation as string,\n        translated: true,\n        catalogue: 'imported',\n        modified: false\n      }));\n    }\n\n    throw new Error('Unrecognized JSON format');\n  }\n\n  private parsePoFile(text: string): TranslationString[] {\n    const translations: TranslationString[] = [];\n    const lines = text.split('\\n');\n    let currentEntry: any = {};\n\n    for (const line of lines) {\n      const trimmed = line.trim();\n\n      if (trimmed.startsWith('msgid ')) {\n        if (currentEntry.msgid && currentEntry.msgstr) {\n          translations.push({\n            id: '',\n            key: currentEntry.msgid,\n            original: currentEntry.msgid,\n            translation: currentEntry.msgstr,\n            translated: !!currentEntry.msgstr,\n            catalogue: 'imported',\n            modified: false\n          });\n        }\n        currentEntry = { msgid: trimmed.slice(7, -1) };\n      } else if (trimmed.startsWith('msgstr ')) {\n        currentEntry.msgstr = trimmed.slice(8, -1);\n      }\n    }\n\n    // Add last entry\n    if (currentEntry.msgid && currentEntry.msgstr) {\n      translations.push({\n        id: '',\n        key: currentEntry.msgid,\n        original: currentEntry.msgid,\n        translation: currentEntry.msgstr,\n        translated: !!currentEntry.msgstr,\n        catalogue: 'imported',\n        modified: false\n      });\n    }\n\n    return translations;\n  }\n\n  private parseCsvFile(text: string): TranslationString[] {\n    const lines = text.split('\\n');\n    const translations: TranslationString[] = [];\n\n    // Skip header if present\n    const startIndex = lines[0]?.includes('Original') ? 1 : 0;\n\n    for (let i = startIndex; i < lines.length; i++) {\n      const line = lines[i]?.trim();\n      if (!line) continue;\n\n      const columns = this.parseCsvLine(line);\n      if (columns.length >= 2) {\n        translations.push({\n          id: '',\n          key: columns[0]!,\n          original: columns[0]!,\n          translation: columns[1]!,\n          translated: !!columns[1],\n          catalogue: columns[2] || 'imported',\n          modified: false\n        });\n      }\n    }\n\n    return translations;\n  }\n\n  private parseCsvLine(line: string): string[] {\n    const result: string[] = [];\n    let current = '';\n    let inQuotes = false;\n\n    for (let i = 0; i < line.length; i++) {\n      const char = line[i];\n\n      if (char === '\"') {\n        if (inQuotes && line[i + 1] === '\"') {\n          current += '\"';\n          i++; // Skip next quote\n        } else {\n          inQuotes = !inQuotes;\n        }\n      } else if (char === ',' && !inQuotes) {\n        result.push(current);\n        current = '';\n      } else {\n        current += char;\n      }\n    }\n\n    result.push(current);\n    return result;\n  }\n\n  async submit(systemId: string, languageCode: string, translations: TranslationString[]): Promise<void> {\n    throw new Error('File backend does not support submission');\n  }\n\n  isAvailable(): boolean {\n    return true;\n  }\n\n  getSystems(): Promise<Array<{ name: string; description: string; id: string }>> {\n    throw new Error('File backend does not support system listing');\n  }\n\n  getStats(systemId: string): Promise<any> {\n    throw new Error('File backend does not support stats');\n  }\n}","import { defineStore } from \"pinia\";\nimport { TranslationBackend, NoOpBackend, FileBackend } from \"./translationBackends\";\nimport { type TranslationSource } from \"./translationSources\";\n\nexport interface TranslationString {\n  id: string;\n  key: string;\n  original: string;\n  translation: string;\n  translated: boolean;\n  catalogue: string;\n  modified?: boolean;\n}\n\nexport interface TranslationCatalogue {\n  id: string;\n  name: string;\n  stringCount: number;\n  strings: TranslationString[];\n}\n\nexport type ExportFormat = \"json\" | \"json-kv\" | \"csv\" | \"po\";\n\nexport const useTranslationStore = defineStore(\"translation\", {\n  state: () => ({\n    strings: {} as Record<string, Set<string>>,\n    catalogues: [] as TranslationCatalogue[],\n    translations: [] as TranslationString[],\n    isLoaded: false,\n    currentSystemId: null as string | null,\n    totalStrings: 0,\n    translatedCount: 0,\n    backend: new NoOpBackend() as TranslationBackend,\n    translationSource: null as TranslationSource | null,\n    isSyncing: false,\n    isSubmitting: false,\n    lastSyncTime: null as number | null,\n    lastSubmitTime: null as number | null,\n  }),\n\n  getters: {\n    systemStringCount: (state) => state.totalStrings,\n\n    systemName: (state) => state.translationSource?.getName() || \"Unknown System\",\n\n    getCatalogueById: (state) => (catalogueId: string) => {\n      return state.catalogues.find(cat => cat.id === catalogueId);\n    },\n\n    getTranslationByKey: (state) => (key: string) => {\n      return state.translations.find(t => t.key === key);\n    },\n\n    getTranslationsByStatus: (state) => (translated: boolean) => {\n      return state.translations.filter(t => t.translated === translated);\n    },\n\n    canSync: (state) => state.backend.isAvailable() && !state.isSyncing,\n\n    canSubmit: (state) => state.backend.isAvailable() && !state.isSubmitting,\n  },\n\n  actions: {\n    // IndexedDB helper methods\n    getStorageKey(systemId: string, languageCode: string): string {\n      return `${systemId}-${languageCode}`;\n    },\n\n    async dbOpen(): Promise<IDBDatabase> {\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open('nr-translations', 2);\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve(request.result);\n\n        request.onupgradeneeded = (event) => {\n          const db = (event.target as IDBOpenDBRequest).result;\n\n          // Clear old store if it exists\n          if (db.objectStoreNames.contains('translations')) {\n            db.deleteObjectStore('translations');\n          }\n\n          // Create new store with composite key\n          const store = db.createObjectStore('translations', { keyPath: 'compositeKey' });\n\n          // Index for querying by system-language combination\n          store.createIndex('systemLanguage', 'systemLanguage', { unique: false });\n          store.createIndex('systemId', 'systemId', { unique: false });\n        };\n      });\n    },\n\n    async dbPutRecord(record: any): Promise<void> {\n      const db = await this.dbOpen();\n      const transaction = db.transaction(['translations'], 'readwrite');\n      const store = transaction.objectStore('translations');\n\n      return new Promise((resolve, reject) => {\n        const request = store.put(record);\n        request.onsuccess = () => resolve();\n        request.onerror = () => reject(request.error);\n      });\n    },\n\n    async dbGetByIndex(indexName: string, value: string): Promise<any[]> {\n      const db = await this.dbOpen();\n      const transaction = db.transaction(['translations'], 'readonly');\n      const store = transaction.objectStore('translations');\n      const index = store.index(indexName);\n\n      return new Promise((resolve, reject) => {\n        const results: any[] = [];\n        const request = index.openCursor(IDBKeyRange.only(value));\n\n        request.onsuccess = (event) => {\n          const cursor = (event.target as IDBRequest).result;\n          if (cursor) {\n            results.push(cursor.value);\n            cursor.continue();\n          } else {\n            resolve(results);\n          }\n        };\n\n        request.onerror = () => reject(request.error);\n      });\n    },\n\n    async dbDeleteByIndex(indexName: string, value: string): Promise<void> {\n      const db = await this.dbOpen();\n      const transaction = db.transaction(['translations'], 'readwrite');\n      const store = transaction.objectStore('translations');\n      const index = store.index(indexName);\n\n      return new Promise((resolve, reject) => {\n        const request = index.openCursor(IDBKeyRange.only(value));\n\n        request.onsuccess = (event) => {\n          const cursor = (event.target as IDBRequest).result;\n          if (cursor) {\n            cursor.delete();\n            cursor.continue();\n          } else {\n            resolve();\n          }\n        };\n\n        request.onerror = () => reject(request.error);\n      });\n    },\n\n    async saveTranslationsToLocal(systemId: string, languageCode: string, translations?: TranslationString[]) {\n      // Only save translated strings to reduce storage\n      const translatedStrings = translations ?? this.translations.filter(t => t.translated);\n      const systemLanguageKey = `${systemId}-${languageCode}`;\n\n      try {\n        // Clear existing translations for this system-language combination\n        await this.dbDeleteByIndex('systemLanguage', systemLanguageKey);\n\n        // Save each translation as individual record\n        for (const translation of translatedStrings) {\n          const record = {\n            compositeKey: `${systemId}-${languageCode}-${translation.key}`,\n            systemId,\n            languageCode,\n            systemLanguage: systemLanguageKey,\n            key: translation.key,\n            translation: translation.translation,\n            catalogue: translation.catalogue,\n            modified: translation.modified,\n            lastSaved: Date.now()\n          };\n\n          await this.dbPutRecord(record);\n        }\n      } catch (error) {\n        console.warn('Failed to save translations to IndexedDB:', error);\n      }\n    },\n\n    async loadTranslationsFromLocal(systemId: string, languageCode: string): Promise<boolean> {\n      const systemLanguageKey = `${systemId}-${languageCode}`;\n\n      try {\n        // Get all saved translations for this system-language\n        const savedTranslations = await this.dbGetByIndex('systemLanguage', systemLanguageKey);\n\n        if (savedTranslations.length === 0) {\n          return false;\n        }\n\n        // Restore translations to current state - optimized with Map lookups\n        const translationMap = new Map(this.translations.map(t => [t.key, t]));\n\n        savedTranslations.forEach((savedTranslation) => {\n          const current = translationMap.get(savedTranslation.key);\n          if (current) {\n            current.translation = savedTranslation.translation || \"\";\n            current.translated = true;\n            current.modified = savedTranslation.modified || false;\n          }\n        });\n\n        // Update catalogues to match - optimized with Map lookup\n        const keyMap = new Map(this.translations.map(t => [t.key, t]));\n\n        this.catalogues.forEach(catalogue => {\n          catalogue.strings.forEach(string => {\n            const translation = keyMap.get(string.key);\n            if (translation) {\n              string.translation = translation.translation;\n              string.translated = translation.translated;\n              string.modified = translation.modified;\n            }\n          });\n        });\n\n        // Update counts\n        this.translatedCount = this.translations.filter(s => s.translated).length;\n\n        return true;\n      } catch (error) {\n        console.warn('Failed to load translations from IndexedDB:', error);\n        return false;\n      }\n    },\n\n    async clearLocalTranslations(systemId: string, languageCode: string) {\n      const systemLanguageKey = `${systemId}-${languageCode}`;\n\n      try {\n        await this.dbDeleteByIndex('systemLanguage', systemLanguageKey);\n      } catch (error) {\n        console.warn('Failed to clear translations from IndexedDB:', error);\n      }\n    },\n\n    async loadTranslationsFromSource(translationSource: TranslationSource, languageCode?: string, progressCallback?: (progress: number, message?: string) => void) {\n      const sourceId = translationSource.getId();\n\n      // Only load if not already loaded for this source\n      if (this.isLoaded && this.currentSystemId === sourceId) {\n        return;\n      }\n\n      try {\n        this.translationSource = translationSource;\n        this.currentSystemId = sourceId;\n\n        // Get translations using the source\n        const { strings: rawStrings, catalogues: catalogueList, translations: allTranslations } =\n          await this.translationSource.getTranslations(languageCode || 'en', progressCallback);\n\n        this.strings = rawStrings;\n        globalThis.strings = rawStrings;\n        this.catalogues = catalogueList;\n        this.translations = allTranslations;\n        globalThis.translations = allTranslations;\n        this.totalStrings = allTranslations.length;\n        this.translatedCount = allTranslations.filter(s => s.translated).length;\n        this.isLoaded = true;\n\n        // Store the translation source\n        this.translationSource = translationSource;\n\n        // Try to restore saved translations from IndexedDB\n        if (languageCode) {\n          await this.loadTranslationsFromLocal(sourceId, languageCode);\n        }\n      } catch (error) {\n        console.error(\"Failed to load translations:\", error);\n        throw error;\n      }\n    },\n\n    async ensureTranslationsLoaded(systemId: string, languageCode: string, progressCallback?: (progress: number, message?: string) => void): Promise<void> {\n      // If translations are already loaded for this exact system, return\n      if (this.isLoaded && this.currentSystemId === systemId) {\n        return;\n      }\n\n      // Always clear cache when loading a different system\n      this.clearCache();\n\n      // Create the appropriate translation source for this systemId\n      const { createTranslationSourceForSystem } = await import(\"./translationSources\");\n      const source = createTranslationSourceForSystem(systemId);\n\n      // Load translations using the source\n      await this.loadTranslationsFromSource(source, languageCode, progressCallback);\n      this.currentSystemId = systemId;\n    },\n\n    updateTranslation(stringId: string, translation: string, systemId?: string, languageCode?: string) {\n      const translationObj = this.translations.find(t => t.id === stringId);\n      if (translationObj) {\n        translationObj.translation = translation;\n        translationObj.modified = true;\n        translationObj.translated = translation.trim() !== \"\";\n\n        // Update translated count\n        this.translatedCount = this.translations.filter(s => s.translated).length;\n\n        // Update the catalogue's string as well\n        const catalogue = this.catalogues.find(cat => cat.id === translationObj.catalogue);\n        if (catalogue) {\n          const catString = catalogue.strings.find(s => s.id === stringId);\n          if (catString) {\n            catString.translation = translation;\n            catString.modified = true;\n            catString.translated = translationObj.translated;\n          }\n        }\n\n        // Auto-save to IndexedDB if system and language are provided\n        if (systemId && languageCode) {\n          this.saveTranslationsToLocal(systemId, languageCode, [translationObj]);\n        }\n      }\n    },\n\n    clearCache() {\n      this.strings = {};\n      this.catalogues = [];\n      this.translations = [];\n      this.isLoaded = false;\n      this.currentSystemId = null;\n      this.translationSource = null;\n      this.totalStrings = 0;\n      this.translatedCount = 0;\n\n      // Clear global variables as well\n      globalThis.strings = {};\n      globalThis.translations = [];\n    },\n\n    // Backend configuration\n    setBackend(backend: TranslationBackend) {\n      this.backend = backend;\n    },\n\n    getCurrentTranslationSource() {\n      return this.translationSource;\n    },\n\n    // Sync translations from file\n    async syncFromFile(file: File, systemId: string, languageCode: string, strategy: 'server-wins' | 'client-wins' | 'ask-user' = 'ask-user'): Promise<{ conflicts: Array<{ key: string, original: string, local: string, server: string }> }> {\n      const fileBackend = new FileBackend(file);\n      const backendTranslations = await fileBackend.sync(systemId, languageCode);\n\n      return await this.syncTranslations(backendTranslations, systemId, languageCode, strategy);\n    },\n\n    // Sync translations from backend with conflict detection\n    async syncFromBackend(systemId: string, languageCode: string, strategy: 'server-wins' | 'client-wins' | 'ask-user' = 'ask-user'): Promise<{ conflicts: Array<{ key: string, original: string, local: string, server: string }> }> {\n      if (!this.backend.isAvailable()) {\n        throw new Error('No backend configured');\n      }\n\n      const backendTranslations = await this.backend.sync(systemId, languageCode);\n\n      return await this.syncTranslations(backendTranslations, systemId, languageCode, strategy);\n    },\n\n    // Core sync logic that handles conflicts and updates\n    async syncTranslations(backendTranslations: TranslationString[], systemId: string, languageCode: string, strategy: 'server-wins' | 'client-wins' | 'ask-user' = 'ask-user'): Promise<{ conflicts: Array<{ key: string, original: string, local: string, server: string }> }> {\n      if (this.isSyncing) {\n        throw new Error('Sync already in progress');\n      }\n\n      this.isSyncing = true;\n\n      try {\n        if (backendTranslations.length === 0) {\n          this.lastSyncTime = Date.now();\n          return { conflicts: [] };\n        }\n\n        const translationMap = new Map(this.translations.map(t => [t.key, t]));\n        const conflicts: Array<{ key: string, original: string, local: string, server: string }> = [];\n        const safeUpdates: Array<{ local: TranslationString, server: TranslationString }> = [];\n\n        // Detect conflicts and safe updates\n        backendTranslations.forEach((serverTranslation) => {\n          const local = translationMap.get(serverTranslation.key);\n\n          if (!local) return;\n\n          // Check for conflicts: both local and server have changes\n          if (local.modified &&\n            local.translation !== serverTranslation.translation &&\n            local.translation.trim() !== '' &&\n            serverTranslation.translation.trim() !== '') {\n            conflicts.push({\n              key: serverTranslation.key,\n              original: local.original,\n              local: local.translation,\n              server: serverTranslation.translation\n            });\n          } else {\n            // Safe to update\n            safeUpdates.push({ local, server: serverTranslation });\n          }\n        });\n\n        // Apply safe updates immediately\n        safeUpdates.forEach(({ local, server }) => {\n          local.translation = server.translation;\n          local.translated = server.translated;\n          local.modified = false;\n        });\n\n        // Handle conflicts based on strategy\n        if (conflicts.length > 0) {\n          if (strategy === 'server-wins') {\n            conflicts.forEach(conflict => {\n              const local = translationMap.get(conflict.key);\n              if (local) {\n                local.translation = conflict.server;\n                local.translated = true;\n                local.modified = false;\n              }\n            });\n          } else if (strategy === 'client-wins') {\n            // Keep local changes, do nothing\n          } else if (strategy === 'ask-user') {\n            // Return conflicts for user to resolve\n            return { conflicts };\n          }\n        }\n\n        // Update catalogues to match\n        this.updateCataloguesFromTranslations();\n\n        // Update counts\n        this.translatedCount = this.translations.filter(s => s.translated).length;\n\n        // Save to local storage\n        await this.saveTranslationsToLocal(systemId, languageCode);\n\n        this.lastSyncTime = Date.now();\n        return { conflicts: strategy === 'ask-user' ? conflicts : [] };\n      } finally {\n        this.isSyncing = false;\n      }\n    },\n\n    // Helper method to update catalogues from translations\n    updateCataloguesFromTranslations() {\n      const keyMap = new Map(this.translations.map(t => [t.key, t]));\n\n      this.catalogues.forEach(catalogue => {\n        catalogue.strings.forEach(string => {\n          const translation = keyMap.get(string.key);\n          if (translation) {\n            string.translation = translation.translation;\n            string.translated = translation.translated;\n            string.modified = translation.modified;\n          }\n        });\n      });\n    },\n\n    // Resolve conflicts with user choices\n    resolveConflicts(conflicts: Array<{ key: string, choice: 'local' | 'server', server: string }>) {\n      const translationMap = new Map(this.translations.map(t => [t.key, t]));\n\n      conflicts.forEach(conflict => {\n        const local = translationMap.get(conflict.key);\n        if (local && conflict.choice === 'server') {\n          local.translation = conflict.server;\n          local.translated = true;\n          local.modified = false;\n        }\n        // If choice is 'local', keep current local translation\n      });\n\n      this.updateCataloguesFromTranslations();\n      this.translatedCount = this.translations.filter(s => s.translated).length;\n    },\n\n    // Submit translations to backend\n    async submitToBackend(systemId: string, languageCode: string, onlyModified: boolean = true): Promise<void> {\n      if (!this.backend.isAvailable()) {\n        throw new Error('No backend configured');\n      }\n\n      if (this.isSubmitting) {\n        throw new Error('Submit already in progress');\n      }\n\n      this.isSubmitting = true;\n\n      try {\n        // Get translations to submit\n        let translationsToSubmit = this.translations.filter(t => t.translated && t.translation.trim() !== '');\n\n        if (onlyModified) {\n          translationsToSubmit = translationsToSubmit.filter(t => t.modified);\n        }\n\n        if (translationsToSubmit.length > 0) {\n          await this.backend.submit(systemId, languageCode, translationsToSubmit);\n\n          // Mark submitted translations as unmodified\n          translationsToSubmit.forEach(t => {\n            t.modified = false;\n          });\n\n          // Update catalogues to match\n          const keyMap = new Map(this.translations.map(t => [t.key, t]));\n\n          this.catalogues.forEach(catalogue => {\n            catalogue.strings.forEach(string => {\n              const translation = keyMap.get(string.key);\n              if (translation) {\n                string.modified = translation.modified;\n              }\n            });\n          });\n\n          // Save to local storage\n          await this.saveTranslationsToLocal(systemId, languageCode);\n        }\n\n        this.lastSubmitTime = Date.now();\n      } finally {\n        this.isSubmitting = false;\n      }\n    },\n\n    exportTranslations(format: ExportFormat, languageCode: string, languageName: string, systemName: string, onlyTranslated: boolean = false, onlyUntranslated: boolean = false): { content: string; filename: string; mimeType: string } {\n      let dataToExport = this.translations;\n\n      if (onlyTranslated) {\n        dataToExport = this.translations.filter(t => t.translated);\n      } else if (onlyUntranslated) {\n        dataToExport = this.translations.filter(t => !t.translated);\n      }\n\n      let content = \"\";\n      let filename = `${systemName}_${languageCode}_translations`;\n      let mimeType = \"\";\n\n      switch (format) {\n        case \"json\":\n          const jsonData = {\n            meta: {\n              system: systemName,\n              language: languageCode,\n              languageName: languageName,\n              exportDate: new Date().toISOString(),\n              totalStrings: dataToExport.length\n            },\n            translations: dataToExport.map(t => ({\n              key: t.key,\n              original: t.original,\n              translation: t.translation || \"\",\n              translated: t.translated,\n              catalogue: t.catalogue\n            }))\n          };\n          content = JSON.stringify(jsonData, null, 2);\n          filename += \".json\";\n          mimeType = \"application/json\";\n          break;\n\n        case \"json-kv\":\n          const kvData = dataToExport\n            .filter((t) => t.translated && t.original !== t.translation)\n            .reduce((acc, t) => {\n              acc[t.key] = t.translation;\n              return acc;\n            }, {} as Record<string, string>);\n          content = JSON.stringify(kvData, null, 2);\n          filename += \"_kv.json\";\n          mimeType = \"application/json\";\n          break;\n\n        case \"csv\":\n          // CSV header\n          content = \"Original,Translation,Catalogue,Status\\n\";\n          dataToExport.forEach(t => {\n            const original = t.original.replace(/\"/g, '\"\"');\n            const translation = (t.translation || \"\").replace(/\"/g, '\"\"');\n            const status = t.translated ? \"translated\" : \"untranslated\";\n            content += `\"${original}\",\"${translation}\",\"${t.catalogue}\",\"${status}\"\\n`;\n          });\n          filename += \".csv\";\n          mimeType = \"text/csv\";\n          break;\n\n        case \"po\":\n          // PO file header\n          content = `# Translations for ${systemName}\\n`;\n          content += `# Language: ${languageName}\\n`;\n          content += `msgid \"\"\\n`;\n          content += `msgstr \"\"\\n`;\n          content += `\"Content-Type: text/plain; charset=UTF-8\\\\n\"\\n`;\n          content += `\"Language: ${languageCode}\\\\n\"\\n\\n`;\n\n          dataToExport.forEach(t => {\n            content += `#: ${t.catalogue}\\n`;\n            content += `msgid \"${t.original.replace(/\"/g, '\\\\\"')}\"\\n`;\n            content += `msgstr \"${(t.translation || \"\").replace(/\"/g, '\\\\\"')}\"\\n\\n`;\n          });\n          filename += \".po\";\n          mimeType = \"text/plain\";\n          break;\n      }\n\n      return { content, filename, mimeType };\n    },\n\n    downloadExport(format: ExportFormat, languageCode: string, languageName: string, systemName: string, onlyTranslated: boolean = false, onlyUntranslated: boolean = false) {\n      const { content, filename, mimeType } = this.exportTranslations(format, languageCode, languageName, systemName, onlyTranslated, onlyUntranslated);\n\n      // Create and download the file\n      const blob = new Blob([content], { type: mimeType });\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement(\"a\");\n      link.href = url;\n      link.download = filename;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      URL.revokeObjectURL(url);\n    }\n  }\n});"],"file":"_nuxt/Cz3oM3EE.js"}