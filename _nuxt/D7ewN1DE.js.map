{"version":3,"mappings":"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","names":["FileBackend","file","systemId","languageCode","text","error","data","key","translation","translations","lines","currentEntry","line","trimmed","startIndex","i","columns","result","current","inQuotes","char","GithubSubmission","title","translationData","t","body","params","fileContent","path","message","description","GithubBackend","url","response","fileData","content","existingTranslations","existingMap","mergedTranslations","finalTranslations","a","b","translationFile","fileExists","checkUrl","issueUrl","editUrl","languageFolders","item","stats","folder","translatedCount","base64","cleanBase64","binaryString","bytes","useTranslationStore","defineStore","state","catalogueId","cat","translated","resolve","reject","request","event","db","store","record","indexName","value","index","results","cursor","compositeKey","systemLanguageKey","translatedStrings","savedTranslations","translationMap","savedTranslation","keyMap","catalogue","string","s","translationSource","progressCallback","sourceId","rawStrings","catalogueList","allTranslations","createTranslationSourceForSystem","__vitePreload","source","stringId","translationObj","catString","backend","strategy","backendTranslations","conflicts","safeUpdates","serverTranslation","local","server","conflict","onlyModified","translationsToSubmit","format","languageName","systemName","onlyTranslated","onlyUntranslated","dataToExport","filename","mimeType","jsonData","kvData","acc","original","status","blob","link"],"ignoreList":[],"sources":["../../../../../../../stores/translationBackends/FileBackend.ts","../../../../../../../utils/githubSubmission.ts","../../../../../../../stores/translationBackends/GithubBackend.ts","../../../../../../../stores/translationStore.ts"],"sourcesContent":["import type { TranslationString } from \"../translationStore\";\nimport type { TranslationBackend } from \"./index\";\n\n// File-based backend implementation\nexport class FileBackend implements TranslationBackend {\n  constructor(private file: File) { }\n\n  async fetchTranslations(systemId: string, languageCode: string): Promise<TranslationString[]> {\n    const text = await this.file.text();\n\n    try {\n      // Try parsing as JSON first\n      if (this.file.name.endsWith('.json')) {\n        return this.parseJsonFile(text);\n      } else if (this.file.name.endsWith('.po')) {\n        return this.parsePoFile(text);\n      } else if (this.file.name.endsWith('.csv')) {\n        return this.parseCsvFile(text);\n      } else {\n        // Try to auto-detect format\n        return this.parseJsonFile(text);\n      }\n    } catch (error) {\n      throw new Error(`Failed to parse file: ${error.message}`);\n    }\n  }\n\n  private parseJsonFile(text: string): TranslationString[] {\n    const data = JSON.parse(text);\n\n    if (data.translations && Array.isArray(data.translations)) {\n      // Full JSON format\n      return data.translations;\n    } else if (typeof data === 'object') {\n      // Key-value JSON format\n      return Object.entries(data).map(([key, translation]) => ({\n        id: '',\n        key,\n        original: key,\n        translation: translation as string,\n        translated: true,\n        catalogue: 'imported',\n        modified: false\n      }));\n    }\n\n    throw new Error('Unrecognized JSON format');\n  }\n\n  private parsePoFile(text: string): TranslationString[] {\n    const translations: TranslationString[] = [];\n    const lines = text.split('\\n');\n    let currentEntry: any = {};\n\n    for (const line of lines) {\n      const trimmed = line.trim();\n\n      if (trimmed.startsWith('msgid ')) {\n        if (currentEntry.msgid && currentEntry.msgstr) {\n          translations.push({\n            id: '',\n            key: currentEntry.msgid,\n            original: currentEntry.msgid,\n            translation: currentEntry.msgstr,\n            translated: !!currentEntry.msgstr,\n            catalogue: 'imported',\n            modified: false\n          });\n        }\n        currentEntry = { msgid: trimmed.slice(7, -1) };\n      } else if (trimmed.startsWith('msgstr ')) {\n        currentEntry.msgstr = trimmed.slice(8, -1);\n      }\n    }\n\n    // Add last entry\n    if (currentEntry.msgid && currentEntry.msgstr) {\n      translations.push({\n        id: '',\n        key: currentEntry.msgid,\n        original: currentEntry.msgid,\n        translation: currentEntry.msgstr,\n        translated: !!currentEntry.msgstr,\n        catalogue: 'imported',\n        modified: false\n      });\n    }\n\n    return translations;\n  }\n\n  private parseCsvFile(text: string): TranslationString[] {\n    const lines = text.split('\\n');\n    const translations: TranslationString[] = [];\n\n    // Skip header if present\n    const startIndex = lines[0]?.includes('Original') ? 1 : 0;\n\n    for (let i = startIndex; i < lines.length; i++) {\n      const line = lines[i]?.trim();\n      if (!line) continue;\n\n      const columns = this.parseCsvLine(line);\n      if (columns.length >= 2) {\n        translations.push({\n          id: '',\n          key: columns[0]!,\n          original: columns[0]!,\n          translation: columns[1]!,\n          translated: !!columns[1],\n          catalogue: columns[2] || 'imported',\n          modified: false\n        });\n      }\n    }\n\n    return translations;\n  }\n\n  private parseCsvLine(line: string): string[] {\n    const result: string[] = [];\n    let current = '';\n    let inQuotes = false;\n\n    for (let i = 0; i < line.length; i++) {\n      const char = line[i];\n\n      if (char === '\"') {\n        if (inQuotes && line[i + 1] === '\"') {\n          current += '\"';\n          i++; // Skip next quote\n        } else {\n          inQuotes = !inQuotes;\n        }\n      } else if (char === ',' && !inQuotes) {\n        result.push(current);\n        current = '';\n      } else {\n        current += char;\n      }\n    }\n\n    result.push(current);\n    return result;\n  }\n\n  async uploadTranslations(systemId: string, languageCode: string, translations: TranslationString[]): Promise<void> {\n    throw new Error('File backend does not support uploading');\n  }\n\n  isAvailable(): boolean {\n    return true;\n  }\n\n  async getStats(systemId: string): Promise<any> {\n    // File backend doesn't have stats, return null\n    return null;\n  }\n}","// Alternative submission methods for serverless architecture\n\nexport interface SubmissionMethod {\n  type: 'github-issue' | 'download' | 'copy';\n  data: any;\n}\n\nexport class GithubSubmission {\n  private static readonly REPO_OWNER = 'NewRecruitEU';\n  private static readonly REPO_NAME = 'translations';\n\n  /**\n   * Create a GitHub issue with the translations (no auth needed)\n   */\n  static createIssueUrl(systemId: string, languageCode: string, translations: any[]): string {\n    const title = `Translation update: ${systemId} - ${languageCode}`;\n\n    // Format translations for issue body\n    const translationData = {\n      system: systemId,\n      language: languageCode,\n      timestamp: new Date().toISOString(),\n      translations: translations.map(t => ({\n        key: t.key,\n        original: t.original,\n        translation: t.translation,\n        catalogue: t.catalogue\n      }))\n    };\n\n    const body = `## Translation Submission\n\n**System:** ${systemId}\n**Language:** ${languageCode}\n**Translated:** ${translations.filter(t => t.translated).length}/${translations.length}\n\n### Translation Data\n\\`\\`\\`json\n${JSON.stringify(translationData, null, 2)}\n\\`\\`\\`\n\n---\n*This issue was created by the translation tool. A maintainer will review and create a PR.*`;\n\n    // Create GitHub issue URL with pre-filled content\n    const params = new URLSearchParams({\n      title,\n      body,\n      labels: 'translation-update,automated'\n    });\n\n    return `https://github.com/${this.REPO_OWNER}/${this.REPO_NAME}/issues/new?${params}`;\n  }\n\n  /**\n   * Generate a file for users to manually create a PR\n   */\n  static generatePRInstructions(systemId: string, languageCode: string, fileContent: string): string {\n    return `# How to submit your translations\n\n1. **Fork the repository:**\n   https://github.com/${this.REPO_OWNER}/${this.REPO_NAME}/fork\n\n2. **Create/update this file in your fork:**\n   Path: \\`${systemId}/${languageCode}/translations.json\\`\n\n3. **Paste this content:**\n\\`\\`\\`json\n${fileContent}\n\\`\\`\\`\n\n4. **Create a Pull Request:**\n   - Go to: https://github.com/${this.REPO_OWNER}/${this.REPO_NAME}/pulls\n   - Click \"New pull request\"\n   - Click \"compare across forks\"\n   - Select your fork\n   - Create the PR with title: \"Update ${languageCode} translations for ${systemId}\"\n\nYour translations will be reviewed and merged by a maintainer.`;\n  }\n\n  /**\n   * Create a direct edit URL that will create a PR (users need to be logged in to GitHub)\n   */\n  static createDirectEditUrl(systemId: string, languageCode: string, fileContent: string): string {\n    const path = `${systemId}/${languageCode}/translations.json`;\n    const message = `Update ${languageCode} translations for ${systemId}`;\n    const description = `Updated translation file with new/modified translations.\\n\\nThis PR was created using the NR Translation Tool.`;\n\n    // GitHub will automatically fork the repo and create a PR if the user doesn't have write access\n    const params = new URLSearchParams({\n      filename: path,\n      value: fileContent,\n      message: message,\n      description: description,\n      target_branch: 'main'\n    });\n\n    return `https://github.com/${this.REPO_OWNER}/${this.REPO_NAME}/new/main?${params}`;\n  }\n}","import type { TranslationString } from \"../translationStore\";\nimport type { TranslationBackend } from \"./index\";\nimport { GithubSubmission } from \"../../utils/githubSubmission\";\n\ninterface GithubTranslationFile {\n  meta: {\n    system: string;\n    language: string;\n    languageName: string;\n    exportDate: string;\n    totalStrings: number;\n  };\n  translations: Array<{\n    key: string;\n    original: string;\n    translation: string;\n    translated: boolean;\n    catalogue: string;\n  }>;\n}\n\nexport class GithubBackend implements TranslationBackend {\n  private readonly owner = \"NewRecruitEU\";\n  private readonly repo = \"translations\";\n  private readonly apiBase = \"https://api.github.com\";\n\n  constructor() { }\n\n  async fetchTranslations(systemId: string, languageCode: string): Promise<TranslationString[]> {\n    try {\n      // Fetch the translations.json file from the repo\n      const path = `${systemId}/${languageCode}/translations.json`;\n      const url = `${this.apiBase}/repos/${this.owner}/${this.repo}/contents/${path}`;\n\n      const response = await fetch(url, {\n        headers: this.getHeaders()\n      });\n\n      if (response.status === 404) {\n        // No translations exist yet for this language\n        return [];\n      }\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch translations: ${response.status} ${response.statusText}`);\n      }\n\n      const fileData = await response.json();\n\n      // Decode base64 content with proper UTF-8 handling\n      const content = this.base64ToUtf8(fileData.content);\n      const translationFile: GithubTranslationFile = JSON.parse(content);\n\n      // Convert to TranslationString format\n      return translationFile.translations.map(t => ({\n        id: `${t.key}-${t.catalogue}`, // Generate ID from key and catalogue\n        key: t.key,\n        original: t.original,\n        translation: t.translation,\n        translated: t.translated,\n        catalogue: t.catalogue,\n        modified: false\n      }));\n    } catch (error) {\n      console.error(\"Error fetching translations from GitHub:\", error);\n      throw error;\n    }\n  }\n\n  async uploadTranslations(systemId: string, languageCode: string, translations: TranslationString[]): Promise<void> {\n    try {\n      // First, fetch existing translations to merge with\n      const existingTranslations = await this.fetchTranslations(systemId, languageCode);\n\n      // Create a map of existing translations by key\n      const existingMap = new Map(existingTranslations.map(t => [t.key, t]));\n\n      // Merge translations: new/modified translations override existing ones\n      const mergedTranslations = new Map(existingMap);\n\n      // Update with new/modified translations\n      translations.forEach(t => {\n        if (t.modified || t.translated) {\n          mergedTranslations.set(t.key, t);\n        }\n      });\n\n      // Convert back to array and sort by key for consistency\n      const finalTranslations = Array.from(mergedTranslations.values())\n        .sort((a, b) => a.key.localeCompare(b.key));\n\n      const translationFile: GithubTranslationFile = {\n        meta: {\n          system: systemId,\n          language: languageCode,\n          languageName: languageCode,\n          exportDate: new Date().toISOString(),\n          totalStrings: finalTranslations.length\n        },\n        translations: finalTranslations.map(t => ({\n          key: t.key,\n          original: t.original,\n          translation: t.translation,\n          translated: t.translated,\n          catalogue: t.catalogue\n        }))\n      };\n\n      const fileContent = JSON.stringify(translationFile, null, 2);\n\n      // Check if file exists\n      const path = `${systemId}/${languageCode}/translations.json`;\n      let fileExists = false;\n      try {\n        const checkUrl = `${this.apiBase}/repos/${this.owner}/${this.repo}/contents/${path}`;\n        const checkResponse = await fetch(checkUrl, { headers: this.getHeaders() });\n        fileExists = checkResponse.ok;\n      } catch {\n        fileExists = false;\n      }\n\n      if (fileExists) {\n        // For existing files, we'll create an issue with the merged translations\n        // since GitHub doesn't support pre-filling content when editing existing files\n        const issueUrl = GithubSubmission.createIssueUrl(systemId, languageCode, finalTranslations);\n        window.open(issueUrl, '_blank');\n        \n        alert('Since the translation file already exists, we\\'ve opened a GitHub issue with your merged translations. A maintainer will review and create a PR with your changes.');\n      } else {\n        // For new files, use the direct edit URL\n        const editUrl = GithubSubmission.createDirectEditUrl(systemId, languageCode, fileContent);\n        window.open(editUrl, '_blank');\n        \n        alert('Opening GitHub to create a new translation file. GitHub will guide you through creating a PR.');\n      }\n    } catch (error) {\n      console.error('Error preparing translations for upload:', error);\n      throw new Error('Failed to prepare translations. Please try again.');\n    }\n  }\n\n  isAvailable(): boolean {\n    return true; // GitHub backend is always available for reading\n  }\n\n  async getStats(systemId: string): Promise<any> {\n    try {\n      // List all language folders for the system\n      const path = systemId;\n      const url = `${this.apiBase}/repos/${this.owner}/${this.repo}/contents/${path}`;\n\n      const response = await fetch(url, {\n        headers: this.getHeaders()\n      });\n\n      if (response.status === 404) {\n        return { languages: [] };\n      }\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch stats: ${response.status} ${response.statusText}`);\n      }\n\n      const contents = await response.json();\n\n      // Filter for directories (language folders)\n      const languageFolders = contents.filter((item: any) => item.type === \"dir\");\n\n      const stats = {\n        languages: [] as Array<{\n          code: string;\n          translatedCount: number;\n          totalCount: number;\n          lastUpdated: string;\n        }>\n      };\n\n      // Fetch translation stats for each language\n      for (const folder of languageFolders) {\n        try {\n          const translations = await this.fetchTranslations(systemId, folder.name);\n          const translatedCount = translations.filter(t => t.translated).length;\n\n          stats.languages.push({\n            code: folder.name,\n            translatedCount,\n            totalCount: translations.length,\n            lastUpdated: new Date().toISOString() // Could be enhanced with actual commit date\n          });\n        } catch (error) {\n          // Skip languages that don't have valid translation files\n          console.warn(`Failed to fetch stats for ${folder.name}:`, error);\n        }\n      }\n\n      return stats;\n    } catch (error) {\n      console.error(\"Error fetching stats from GitHub:\", error);\n      return { languages: [] };\n    }\n  }\n\n  // Helper methods\n  private getHeaders(): HeadersInit {\n    return {\n      \"Accept\": \"application/vnd.github.v3+json\"\n    };\n  }\n\n  private base64ToUtf8(base64: string): string {\n    // Remove any whitespace from the base64 string\n    const cleanBase64 = base64.replace(/\\s/g, '');\n    \n    // Decode base64 to bytes\n    const binaryString = atob(cleanBase64);\n    \n    // Convert binary string to Uint8Array\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    \n    // Decode UTF-8 bytes to string\n    return new TextDecoder('utf-8').decode(bytes);\n  }\n}","import { defineStore } from \"pinia\";\nimport { TranslationBackend, NoOpBackend, FileBackend, GithubBackend } from \"./translationBackends\";\nimport { type TranslationSource } from \"./translationSources\";\n\nexport interface TranslationString {\n  id: string;\n  key: string;\n  original: string;\n  translation: string;\n  translated: boolean;\n  catalogue: string;\n  modified?: boolean;\n}\n\nexport interface TranslationCatalogue {\n  id: string;\n  name: string;\n  stringCount: number;\n  strings: TranslationString[];\n}\n\nexport type ExportFormat = \"json\" | \"json-kv\" | \"csv\" | \"po\";\n\nexport const useTranslationStore = defineStore(\"translation\", {\n  state: () => ({\n    strings: {} as Record<string, Set<string>>,\n    catalogues: [] as TranslationCatalogue[],\n    translations: [] as TranslationString[],\n    isLoaded: false,\n    currentSystemId: null as string | null,\n    totalStrings: 0,\n    translatedCount: 0,\n    backend: new GithubBackend() as TranslationBackend,\n    translationSource: null as TranslationSource | null,\n    isSyncing: false,\n    isSubmitting: false,\n    lastSyncTime: null as number | null,\n    lastSubmitTime: null as number | null,\n  }),\n\n  getters: {\n    systemStringCount: (state) => state.totalStrings,\n\n    systemName: (state) => state.translationSource?.getName() || \"Unknown System\",\n\n    getCatalogueById: (state) => (catalogueId: string) => {\n      return state.catalogues.find(cat => cat.id === catalogueId);\n    },\n\n    getTranslationByKey: (state) => (key: string) => {\n      return state.translations.find(t => t.key === key);\n    },\n\n    getTranslationsByStatus: (state) => (translated: boolean) => {\n      return state.translations.filter(t => t.translated === translated);\n    },\n\n    canSync: (state) => state.backend.isAvailable() && !state.isSyncing,\n\n    canSubmit: (state) => state.backend.isAvailable() && !state.isSubmitting,\n  },\n\n  actions: {\n    // IndexedDB helper methods\n    getStorageKey(systemId: string, languageCode: string): string {\n      return `${systemId}-${languageCode}`;\n    },\n\n    async dbOpen(): Promise<IDBDatabase> {\n      return new Promise((resolve, reject) => {\n        const request = indexedDB.open('nr-translations', 2);\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve(request.result);\n\n        request.onupgradeneeded = (event) => {\n          const db = (event.target as IDBOpenDBRequest).result;\n\n          // Clear old store if it exists\n          if (db.objectStoreNames.contains('translations')) {\n            db.deleteObjectStore('translations');\n          }\n\n          // Create new store with composite key\n          const store = db.createObjectStore('translations', { keyPath: 'compositeKey' });\n\n          // Index for querying by system-language combination\n          store.createIndex('systemLanguage', 'systemLanguage', { unique: false });\n          store.createIndex('systemId', 'systemId', { unique: false });\n        };\n      });\n    },\n\n    async dbPutRecord(record: any): Promise<void> {\n      const db = await this.dbOpen();\n      const transaction = db.transaction(['translations'], 'readwrite');\n      const store = transaction.objectStore('translations');\n\n      return new Promise((resolve, reject) => {\n        const request = store.put(record);\n        request.onsuccess = () => resolve();\n        request.onerror = () => reject(request.error);\n      });\n    },\n\n    async dbGetByIndex(indexName: string, value: string): Promise<any[]> {\n      const db = await this.dbOpen();\n      const transaction = db.transaction(['translations'], 'readonly');\n      const store = transaction.objectStore('translations');\n      const index = store.index(indexName);\n\n      return new Promise((resolve, reject) => {\n        const results: any[] = [];\n        const request = index.openCursor(IDBKeyRange.only(value));\n\n        request.onsuccess = (event) => {\n          const cursor = (event.target as IDBRequest).result;\n          if (cursor) {\n            results.push(cursor.value);\n            cursor.continue();\n          } else {\n            resolve(results);\n          }\n        };\n\n        request.onerror = () => reject(request.error);\n      });\n    },\n\n    async dbDeleteByIndex(indexName: string, value: string): Promise<void> {\n      const db = await this.dbOpen();\n      const transaction = db.transaction(['translations'], 'readwrite');\n      const store = transaction.objectStore('translations');\n      const index = store.index(indexName);\n\n      return new Promise((resolve, reject) => {\n        const request = index.openCursor(IDBKeyRange.only(value));\n\n        request.onsuccess = (event) => {\n          const cursor = (event.target as IDBRequest).result;\n          if (cursor) {\n            cursor.delete();\n            cursor.continue();\n          } else {\n            resolve();\n          }\n        };\n\n        request.onerror = () => reject(request.error);\n      });\n    },\n\n    async dbDeleteByCompositeKey(compositeKey: string): Promise<void> {\n      const db = await this.dbOpen();\n      const transaction = db.transaction(['translations'], 'readwrite');\n      const store = transaction.objectStore('translations');\n\n      return new Promise((resolve, reject) => {\n        const request = store.delete(compositeKey);\n        request.onsuccess = () => resolve();\n        request.onerror = () => reject(request.error);\n      });\n    },\n\n    async saveTranslationsToLocal(systemId: string, languageCode: string, translations?: TranslationString[]) {\n      const systemLanguageKey = `${systemId}-${languageCode}`;\n\n      try {\n        if (translations && translations.length > 0) {\n          // Save specific translations (for individual updates)\n          for (const translation of translations) {\n            // Only save if translated\n            if (translation.translated) {\n              const record = {\n                compositeKey: `${systemId}-${languageCode}-${translation.key}`,\n                systemId,\n                languageCode,\n                systemLanguage: systemLanguageKey,\n                key: translation.key,\n                translation: translation.translation,\n                catalogue: translation.catalogue,\n                modified: translation.modified,\n                lastSaved: Date.now()\n              };\n\n              await this.dbPutRecord(record);\n            } else {\n              // If not translated, remove the record if it exists\n              await this.dbDeleteByCompositeKey(`${systemId}-${languageCode}-${translation.key}`);\n            }\n          }\n        } else {\n          // Full save - clear and save all translated strings\n          await this.dbDeleteByIndex('systemLanguage', systemLanguageKey);\n          \n          const translatedStrings = this.translations.filter(t => t.translated);\n          for (const translation of translatedStrings) {\n            const record = {\n              compositeKey: `${systemId}-${languageCode}-${translation.key}`,\n              systemId,\n              languageCode,\n              systemLanguage: systemLanguageKey,\n              key: translation.key,\n              translation: translation.translation,\n              catalogue: translation.catalogue,\n              modified: translation.modified,\n              lastSaved: Date.now()\n            };\n\n            await this.dbPutRecord(record);\n          }\n        }\n      } catch (error) {\n        console.warn('Failed to save translations to IndexedDB:', error);\n      }\n    },\n\n    async loadTranslationsFromLocal(systemId: string, languageCode: string): Promise<boolean> {\n      const systemLanguageKey = `${systemId}-${languageCode}`;\n\n      try {\n        // Get all saved translations for this system-language\n        const savedTranslations = await this.dbGetByIndex('systemLanguage', systemLanguageKey);\n\n        if (savedTranslations.length === 0) {\n          return false;\n        }\n\n        // Restore translations to current state - optimized with Map lookups\n        const translationMap = new Map(this.translations.map(t => [t.key, t]));\n\n        savedTranslations.forEach((savedTranslation) => {\n          const current = translationMap.get(savedTranslation.key);\n          if (current) {\n            current.translation = savedTranslation.translation || \"\";\n            current.translated = true;\n            current.modified = savedTranslation.modified || false;\n          }\n        });\n\n        // Update catalogues to match - optimized with Map lookup\n        const keyMap = new Map(this.translations.map(t => [t.key, t]));\n\n        this.catalogues.forEach(catalogue => {\n          catalogue.strings.forEach(string => {\n            const translation = keyMap.get(string.key);\n            if (translation) {\n              string.translation = translation.translation;\n              string.translated = translation.translated;\n              string.modified = translation.modified;\n            }\n          });\n        });\n\n        // Update counts\n        this.translatedCount = this.translations.filter(s => s.translated).length;\n\n        return true;\n      } catch (error) {\n        console.warn('Failed to load translations from IndexedDB:', error);\n        return false;\n      }\n    },\n\n    async clearLocalTranslations(systemId: string, languageCode: string) {\n      const systemLanguageKey = `${systemId}-${languageCode}`;\n\n      try {\n        await this.dbDeleteByIndex('systemLanguage', systemLanguageKey);\n      } catch (error) {\n        console.warn('Failed to clear translations from IndexedDB:', error);\n      }\n    },\n\n    async loadTranslationsFromSource(translationSource: TranslationSource, languageCode?: string, progressCallback?: (progress: number, message?: string) => void) {\n      const sourceId = translationSource.getId();\n\n      // Only load if not already loaded for this source\n      if (this.isLoaded && this.currentSystemId === sourceId) {\n        return;\n      }\n\n      try {\n        this.translationSource = translationSource;\n        this.currentSystemId = sourceId;\n\n        // Get translations using the source\n        const { strings: rawStrings, catalogues: catalogueList, translations: allTranslations } =\n          await this.translationSource.getTranslations(languageCode || 'en', progressCallback);\n\n        this.strings = rawStrings;\n        globalThis.strings = rawStrings;\n        this.catalogues = catalogueList;\n        this.translations = allTranslations;\n        globalThis.translations = allTranslations;\n        this.totalStrings = allTranslations.length;\n        this.translatedCount = allTranslations.filter(s => s.translated).length;\n        this.isLoaded = true;\n\n        // Store the translation source\n        this.translationSource = translationSource;\n\n        // Try to restore saved translations from IndexedDB\n        if (languageCode) {\n          await this.loadTranslationsFromLocal(sourceId, languageCode);\n        }\n      } catch (error) {\n        console.error(\"Failed to load translations:\", error);\n        throw error;\n      }\n    },\n\n    async ensureTranslationsLoaded(systemId: string, languageCode: string, progressCallback?: (progress: number, message?: string) => void): Promise<void> {\n      // If translations are already loaded for this exact system, return\n      if (this.isLoaded && this.currentSystemId === systemId) {\n        return;\n      }\n\n      // Always clear cache when loading a different system\n      this.clearCache();\n\n      // Create the appropriate translation source for this systemId\n      const { createTranslationSourceForSystem } = await import(\"./translationSources\");\n      const source = createTranslationSourceForSystem(systemId);\n\n      // Load translations using the source\n      await this.loadTranslationsFromSource(source, languageCode, progressCallback);\n      this.currentSystemId = systemId;\n    },\n\n    updateTranslation(stringId: string, translation: string, systemId?: string, languageCode?: string) {\n      const translationObj = this.translations.find(t => t.id === stringId);\n      if (translationObj) {\n        translationObj.translation = translation;\n        translationObj.modified = true;\n        translationObj.translated = translation.trim() !== \"\";\n\n        // Update translated count\n        this.translatedCount = this.translations.filter(s => s.translated).length;\n\n        // Update the catalogue's string as well\n        const catalogue = this.catalogues.find(cat => cat.id === translationObj.catalogue);\n        if (catalogue) {\n          const catString = catalogue.strings.find(s => s.id === stringId);\n          if (catString) {\n            catString.translation = translation;\n            catString.modified = true;\n            catString.translated = translationObj.translated;\n          }\n        }\n\n        // Auto-save to IndexedDB if system and language are provided\n        if (systemId && languageCode) {\n          this.saveTranslationsToLocal(systemId, languageCode, [translationObj]);\n        }\n      }\n    },\n\n    clearCache() {\n      this.strings = {};\n      this.catalogues = [];\n      this.translations = [];\n      this.isLoaded = false;\n      this.currentSystemId = null;\n      this.translationSource = null;\n      this.totalStrings = 0;\n      this.translatedCount = 0;\n\n      // Clear global variables as well\n      globalThis.strings = {};\n      globalThis.translations = [];\n    },\n\n    // Backend configuration\n    setBackend(backend: TranslationBackend) {\n      this.backend = backend;\n    },\n\n    getCurrentTranslationSource() {\n      return this.translationSource;\n    },\n\n    // Sync translations from file\n    async syncFromFile(file: File, systemId: string, languageCode: string, strategy: 'server-wins' | 'client-wins' | 'ask-user' = 'ask-user'): Promise<{ conflicts: Array<{ key: string, original: string, local: string, server: string }> }> {\n      const fileBackend = new FileBackend(file);\n      const backendTranslations = await fileBackend.fetchTranslations(systemId, languageCode);\n\n      return await this.syncTranslations(backendTranslations, systemId, languageCode, strategy);\n    },\n\n    // Sync translations from backend with conflict detection\n    async syncFromBackend(systemId: string, languageCode: string, strategy: 'server-wins' | 'client-wins' | 'ask-user' = 'ask-user'): Promise<{ conflicts: Array<{ key: string, original: string, local: string, server: string }> }> {\n      if (!this.backend.isAvailable()) {\n        throw new Error('No backend configured');\n      }\n\n      const backendTranslations = await this.backend.fetchTranslations(systemId, languageCode);\n\n      return await this.syncTranslations(backendTranslations, systemId, languageCode, strategy);\n    },\n\n    // Core sync logic that handles conflicts and updates\n    async syncTranslations(backendTranslations: TranslationString[], systemId: string, languageCode: string, strategy: 'server-wins' | 'client-wins' | 'ask-user' = 'ask-user'): Promise<{ conflicts: Array<{ key: string, original: string, local: string, server: string }> }> {\n      if (this.isSyncing) {\n        throw new Error('Sync already in progress');\n      }\n\n      this.isSyncing = true;\n\n      try {\n        if (backendTranslations.length === 0) {\n          this.lastSyncTime = Date.now();\n          return { conflicts: [] };\n        }\n\n        const translationMap = new Map(this.translations.map(t => [t.key, t]));\n        const conflicts: Array<{ key: string, original: string, local: string, server: string }> = [];\n        const safeUpdates: Array<{ local: TranslationString, server: TranslationString }> = [];\n\n        // Detect conflicts and safe updates\n        backendTranslations.forEach((serverTranslation) => {\n          const local = translationMap.get(serverTranslation.key);\n\n          if (!local) return;\n\n          // Check for conflicts: both local and server have changes\n          if (local.modified &&\n            local.translation !== serverTranslation.translation &&\n            local.translation.trim() !== '' &&\n            serverTranslation.translation.trim() !== '') {\n            conflicts.push({\n              key: serverTranslation.key,\n              original: local.original,\n              local: local.translation,\n              server: serverTranslation.translation\n            });\n          } else {\n            // Safe to update\n            safeUpdates.push({ local, server: serverTranslation });\n          }\n        });\n\n        // Apply safe updates immediately\n        safeUpdates.forEach(({ local, server }) => {\n          local.translation = server.translation;\n          local.translated = server.translated;\n          local.modified = false;\n        });\n\n        // Handle conflicts based on strategy\n        if (conflicts.length > 0) {\n          if (strategy === 'server-wins') {\n            conflicts.forEach(conflict => {\n              const local = translationMap.get(conflict.key);\n              if (local) {\n                local.translation = conflict.server;\n                local.translated = true;\n                local.modified = false;\n              }\n            });\n          } else if (strategy === 'client-wins') {\n            // Keep local changes, do nothing\n          } else if (strategy === 'ask-user') {\n            // Return conflicts for user to resolve\n            return { conflicts };\n          }\n        }\n\n        // Update catalogues to match\n        this.updateCataloguesFromTranslations();\n\n        // Update counts\n        this.translatedCount = this.translations.filter(s => s.translated).length;\n\n        // Save to local storage\n        await this.saveTranslationsToLocal(systemId, languageCode);\n\n        this.lastSyncTime = Date.now();\n        return { conflicts: strategy === 'ask-user' ? conflicts : [] };\n      } finally {\n        this.isSyncing = false;\n      }\n    },\n\n    // Helper method to update catalogues from translations\n    updateCataloguesFromTranslations() {\n      const keyMap = new Map(this.translations.map(t => [t.key, t]));\n\n      this.catalogues.forEach(catalogue => {\n        catalogue.strings.forEach(string => {\n          const translation = keyMap.get(string.key);\n          if (translation) {\n            string.translation = translation.translation;\n            string.translated = translation.translated;\n            string.modified = translation.modified;\n          }\n        });\n      });\n    },\n\n    // Resolve conflicts with user choices\n    resolveConflicts(conflicts: Array<{ key: string, choice: 'local' | 'server', server: string }>) {\n      const translationMap = new Map(this.translations.map(t => [t.key, t]));\n\n      conflicts.forEach(conflict => {\n        const local = translationMap.get(conflict.key);\n        if (local && conflict.choice === 'server') {\n          local.translation = conflict.server;\n          local.translated = true;\n          local.modified = false;\n        }\n        // If choice is 'local', keep current local translation\n      });\n\n      this.updateCataloguesFromTranslations();\n      this.translatedCount = this.translations.filter(s => s.translated).length;\n    },\n\n    // Submit translations to backend\n    async submitToBackend(systemId: string, languageCode: string, onlyModified: boolean = true): Promise<void> {\n      if (!this.backend.isAvailable()) {\n        throw new Error('No backend configured');\n      }\n\n      if (this.isSubmitting) {\n        throw new Error('Submit already in progress');\n      }\n\n      this.isSubmitting = true;\n\n      try {\n        // Get translations to submit\n        let translationsToSubmit = this.translations.filter(t => t.translated && t.translation.trim() !== '');\n\n        if (onlyModified) {\n          translationsToSubmit = translationsToSubmit.filter(t => t.modified);\n        }\n\n        if (translationsToSubmit.length > 0) {\n          await this.backend.uploadTranslations(systemId, languageCode, translationsToSubmit);\n\n          // Mark submitted translations as unmodified\n          translationsToSubmit.forEach(t => {\n            t.modified = false;\n          });\n\n          // Update catalogues to match\n          const keyMap = new Map(this.translations.map(t => [t.key, t]));\n\n          this.catalogues.forEach(catalogue => {\n            catalogue.strings.forEach(string => {\n              const translation = keyMap.get(string.key);\n              if (translation) {\n                string.modified = translation.modified;\n              }\n            });\n          });\n\n          // Save to local storage\n          await this.saveTranslationsToLocal(systemId, languageCode);\n        }\n\n        this.lastSubmitTime = Date.now();\n      } finally {\n        this.isSubmitting = false;\n      }\n    },\n\n    exportTranslations(format: ExportFormat, languageCode: string, languageName: string, systemName: string, onlyTranslated: boolean = false, onlyUntranslated: boolean = false): { content: string; filename: string; mimeType: string } {\n      let dataToExport = this.translations;\n\n      if (onlyTranslated) {\n        dataToExport = this.translations.filter(t => t.translated);\n      } else if (onlyUntranslated) {\n        dataToExport = this.translations.filter(t => !t.translated);\n      }\n\n      let content = \"\";\n      let filename = `${systemName}_${languageCode}_translations`;\n      let mimeType = \"\";\n\n      switch (format) {\n        case \"json\":\n          const jsonData = {\n            meta: {\n              system: systemName,\n              language: languageCode,\n              languageName: languageName,\n              exportDate: new Date().toISOString(),\n              totalStrings: dataToExport.length\n            },\n            translations: dataToExport.map(t => ({\n              key: t.key,\n              original: t.original,\n              translation: t.translation || \"\",\n              translated: t.translated,\n              catalogue: t.catalogue\n            }))\n          };\n          content = JSON.stringify(jsonData, null, 2);\n          filename += \".json\";\n          mimeType = \"application/json\";\n          break;\n\n        case \"json-kv\":\n          const kvData = dataToExport\n            .filter((t) => t.translated && t.original !== t.translation)\n            .reduce((acc, t) => {\n              acc[t.key] = t.translation;\n              return acc;\n            }, {} as Record<string, string>);\n          content = JSON.stringify(kvData, null, 2);\n          filename += \"_kv.json\";\n          mimeType = \"application/json\";\n          break;\n\n        case \"csv\":\n          // CSV header\n          content = \"Original,Translation,Catalogue,Status\\n\";\n          dataToExport.forEach(t => {\n            const original = t.original.replace(/\"/g, '\"\"');\n            const translation = (t.translation || \"\").replace(/\"/g, '\"\"');\n            const status = t.translated ? \"translated\" : \"untranslated\";\n            content += `\"${original}\",\"${translation}\",\"${t.catalogue}\",\"${status}\"\\n`;\n          });\n          filename += \".csv\";\n          mimeType = \"text/csv\";\n          break;\n\n        case \"po\":\n          // PO file header\n          content = `# Translations for ${systemName}\\n`;\n          content += `# Language: ${languageName}\\n`;\n          content += `msgid \"\"\\n`;\n          content += `msgstr \"\"\\n`;\n          content += `\"Content-Type: text/plain; charset=UTF-8\\\\n\"\\n`;\n          content += `\"Language: ${languageCode}\\\\n\"\\n\\n`;\n\n          dataToExport.forEach(t => {\n            content += `#: ${t.catalogue}\\n`;\n            content += `msgid \"${t.original.replace(/\"/g, '\\\\\"')}\"\\n`;\n            content += `msgstr \"${(t.translation || \"\").replace(/\"/g, '\\\\\"')}\"\\n\\n`;\n          });\n          filename += \".po\";\n          mimeType = \"text/plain\";\n          break;\n      }\n\n      return { content, filename, mimeType };\n    },\n\n    downloadExport(format: ExportFormat, languageCode: string, languageName: string, systemName: string, onlyTranslated: boolean = false, onlyUntranslated: boolean = false) {\n      const { content, filename, mimeType } = this.exportTranslations(format, languageCode, languageName, systemName, onlyTranslated, onlyUntranslated);\n\n      // Create and download the file\n      const blob = new Blob([content], { type: mimeType });\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement(\"a\");\n      link.href = url;\n      link.download = filename;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      URL.revokeObjectURL(url);\n    }\n  }\n});"],"file":"_nuxt/D7ewN1DE.js"}